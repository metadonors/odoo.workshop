[
{
	"uri": "https://metadonors.github.io/odoo.workshop/application_logic/wizard/",
	"title": "Wizard",
	"tags": [],
	"description": "",
	"content": " I wizard sono uno strumento molto utile per fornire agli utenti un interfaccia per effettuare operazioni complesse sui dati. Per esempio chiedendogli dati aggiuntivi rispetto alle operazioni che stanno facendo oppure semplicemente per avere uno strumento di validazione delle operazioni da effettuare.\nCreare un wizard I wizard di solito risiedono nella cartella wizards/ all\u0026rsquo;interno dei moduli. Cominciamo a creare il nosto wizard nella cartella del modulo todo_plus creando la seguente struttura\ntodo_plus/ models/ [...] security/ [...] views/ [...] # Aggiungiamo questo wizards/ __init__.py todo_wizard.py todo_wizard.xml __init__.py __manifest__.py  All\u0026rsquo;interno del file todo_plus/__init.py__ aggiungiamo\nfrom . import wizards  All\u0026rsquo;interno del file todo_plus/wizards/__init.py__ aggiungiamo\nfrom . import todo_wizard  All\u0026rsquo;interno del file todo_plus/__manifest.py__ aggiungiamo\n{ 'name': 'TODO Plus', 'description': \u0026quot;Maggiori funzionalita per l'app TODO\u0026quot;, 'author': 'Metadonors', 'depends': ['todo_user'], 'data': [ 'security/todo_project_acl.xml', 'security/todo_tag_acl.xml', 'views/todo_task.xml', 'views/todo_project.xml', 'wizards/todo_wizard.xml' # \u0026lt;--- Aggiungiamo questo ] }  Il modello del wizard Un wizard visualizza una Form View all\u0026rsquo;utente, solitamente all\u0026rsquo;interno di una finestra modale. Questa vista è implementata con la stessa architattura che abbiamo visto finora con l\u0026rsquo;unica differenza che il modello del wizard erediterà dalla classe models.TransientModel anzichè dalla classe models.Models. Questo tipo di modelli vengono salvati in database come i modelli classici con l\u0026rsquo;unica differenza che vengono automaticamente cancellati ogni giorno.\nQuindi apriamo il file todo_plus/wizards/todo_wizard.py e scriviamo\n# -*- coding: utf-8 -*- from odoo import models, fields, api class TodoWizard(models.TransientModel): _name = 'todo.wizard' _desctiption = 'Todo Wizard per assegnazioni massive' todo_ids = fields.Many2many('todo.task', string='Tasks') new_deadline_date = fields.Date(string='Nuova deadline') new_user_id = fields.Many2one('res.users', string='Nuovo Responsabile')  La vista del wizard Le viste dei wizard sono uguali alle viste classiche, con due differenze:\n Può essere inserita una sezione \u0026lt;footer\u0026gt; per contenere i pulsanti del wizard Può essere inserito un pulsante con special=\u0026ldquo;cancel\u0026rdquo; che si ooccupa di chiudere il wizard  Quindi apriamo il file todo_plus/wizards/todo_wizard.xml e scriviamo\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_wizard_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.wizard.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.wizard\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;div class=\u0026quot;oe_right\u0026quot;\u0026gt; \u0026lt;button type=\u0026quot;object\u0026quot; name=\u0026quot;do_count_todos\u0026quot; string=\u0026quot;Conta\u0026quot;/\u0026gt; \u0026lt;button type=\u0026quot;object\u0026quot; name=\u0026quot;do_select_all\u0026quot; string=\u0026quot;Seleziona tutti\u0026quot;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;field name=\u0026quot;todo_ids\u0026quot;\u0026gt; \u0026lt;tree\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;deadline_date\u0026quot;/\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;group\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026quot;new_user_id\u0026quot;/\u0026gt;\u0026lt;/group\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026quot;new_deadline_date\u0026quot;/\u0026gt;\u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;button type=\u0026quot;object\u0026quot; name=\u0026quot;do_mass_update\u0026quot; string=\u0026quot;Riassegna\u0026quot; class=\u0026quot;oe_highlight\u0026quot; attrs=\u0026quot;{'invisible':[('new_user_id', '=', False)]}\u0026quot;/\u0026gt; \u0026lt;button special=\u0026quot;cancel\u0026quot; string=\u0026quot;Annulla\u0026quot;/\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;act_window id=\u0026quot;todo_app.action_todo_wizard\u0026quot; name=\u0026quot;Todo Wizard\u0026quot; src_model=\u0026quot;todo.task\u0026quot; res_model=\u0026quot;todo.wizard\u0026quot; view_mode=\u0026quot;form\u0026quot; target=\u0026quot;new\u0026quot; multi=\u0026quot;True\u0026quot;/\u0026gt; \u0026lt;/odoo\u0026gt;   $ docker-compose run odoo upgrade todo_user  ricaricare la pagine nel nostro browser e dalla lista dei todo selezioniamo qualche check box. Apparirà il menu Action al cui interno ci sarà il sottomenu Todo Wizard. Premendo si dovrebbe aprire il nostro wizard\nLa logica applicativa del wizard A questo punto non ci rimane che implementare la logica dietro il nostro wizard. Escluso il tasto cancel, abbiamo tre pulsanti che devono essere programmati. Cominciamo con il tasto principale Riassegna\nIl metodo chiamato dal pulsante è do_mass_update e, come gli altri, dovrà essere definito nel modello\nQuindi apriamo il file todo_plus/wizards/todo_wizard.py e aggiungiamo in cima al file\nfrom odoo import exceptions import logging log = logging.getLogger(__name__)  nel corpo della classe invece aggiungiamo\n@api.multi def do_mass_update(self): self.ensure_one() if not self.new_user_id: raise exceptions.ValidationError(\u0026quot;E' necessario specificare un utente\u0026quot;) log.debug(\u0026quot;Mass update on todos %s\u0026quot; % self.todo_ids.ids) vals = {} if self.new_deadline_date: vals['deadline_date'] = self.new_deadline_date vals['user_id'] = self.new_user_id.id self.todo_ids.write(vals)  Questo metodo solleva un errore se l\u0026rsquo;utente cerca di inviare il form senza specificare un responsabile da assegnare ai todo selezionati.\nOra vediamo come implementare il conteggio dei task aperti, aggiungiamo sempre nel corpo della modello del wizard:\n@api.multi def do_count_todos(self): count = self.env['todo.task'].search_count([('is_done', '=', False)]) raise exceptions.Warning(\u0026quot;Ci sono %d todo ancora aperti\u0026quot; % count)  per l\u0026rsquo;ultimo metodo (Seleziona tutti) invece c\u0026rsquo;è un piccolo problema: ogni volta che premiamo un bottone in un wizard e la chiamata non ritorna un eccezione, Oddo chiude automaticamente la finestra popup. La soluzione a questo è qquella di restituire un\u0026rsquo;azione che dice ad odoo di riaprire il wizard, vediamo come:\n@api.multi def _reopen_wizard(self): self.ensure_one() # restituiamo un dizionario rappresentate l'action che riaprira' questo wizard return { 'type': 'ir.actions.act_window', 'res_model': self._name, # questo modello 'res_id': self.id, # l'id del wizard corrente 'view_type': 'form', 'view_mode': 'form', 'target': 'new' } @api.multi def do_select_all(self): self.ensure_one() open_todos = self.env['todo.task'].search([ ('is_done', '=', False) ]) self.todo_ids = open_todos return self._reopen_wizard()  "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/views/menu_actions/",
	"title": "MenuItem e Actions",
	"tags": [],
	"description": "",
	"content": " Gli oggetti del Menu I MenuItem sono oggetti salvati nella modello ir.ui.menu and possono essere visualizzati nel menu tecnico:\nSettings -\u0026gt; Technical -\u0026gt; User Interface -\u0026gt; Menu Items\nSono organizzati in una struttura ad albero. I menu radice (top-level) vengono listati nell\u0026rsquo;elenco completo delle applicazioni, ogni applicazione deve quindi avere almeno un elemento del menu per poter essere visualizzata.\nIl primo sottolivello di menu crea il menu principale dell\u0026rsquo;applicazione, i successivi vengono rappresentati come menu dropdown nei rispettivi padri.\nUn esempio di menu di secondo livello che abbiamo aggiunto con il nostro modulo todo_plus\n\u0026lt;menuitem id=\u0026quot;menu_todo_project\u0026quot; parent=\u0026quot;todo_app.menu_todo_task\u0026quot; name=\u0026quot;Progetti\u0026quot; action=\u0026quot;action_todo_project\u0026quot; sequence=\u0026quot;2\u0026quot; /\u0026gt;  Window Actions Una Window Action comanda le azioni che possono essere compiute attraverso l\u0026rsquo;interfaccia utente e solitamente vengono associate a dei MenuItem oppure a dei bottoni. Principalmente comunicano alla UI su quale tipo di modello andare a lavorare e quali viste del modello rendere disponibili all\u0026rsquo;utente. Ad ogni azione può opzionalmente essere legato un domain e un context che andranno a modificare il comportamente specifico del sistema (vedi la prossima sezione)\nSempre nel nostro modulo todo_plus abbiamo legato al menu dei progetti questa action:\n\u0026lt;act_window id=\u0026quot;action_todo_project\u0026quot; name=\u0026quot;Progetti\u0026quot; res_model=\u0026quot;todo.project\u0026quot; view_mode=\u0026quot;tree,form\u0026quot; /\u0026gt;  "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/api/panoramica/",
	"title": "Panoramica",
	"tags": [],
	"description": "",
	"content": " Il server di Odoo fornisce un API esterna che può essere utilizzata da applicazioni terze per integrarsi. L\u0026rsquo;API sono le stesse che utilizza il client web ufficiale di Odoo per funzionare. Quindi qualsiasi funzionalità utlizzata nel client web può essere utilizzita direttamente tramite API.\nLe API di Odoo supportano i protocolli XML-RPC e JSON-RPC, è quindi possibili scrivere integrazioni in qualsiasi linguaggio che supporti questi due protocolli. Per esempio nella documentazione ufficiale ci sono esempi per: Python, PHP, Ruby e Java.\nPer questioni di chiarezza continueremo con i nostri esempi in Python. Inoltre faremo ricorso a una libreria python specifica che crea un\u0026rsquo;astrazione sopra le API base per ricreare un\u0026rsquo;interfaccia quanto più possibile a quella utilizzata direttamente all\u0026rsquo;interno del framework.\nLa libreria a cui faremo ricorso è OdooRPC\nSolitamente potete installarla nel vostro ambiente python con il comando\n$ pip install OdooRPC  Per semplificare però gli esempi di questo corso, abbiamo aggiungo un comando specifico alla nostra immagine docker che ci permette di avviare una shell interattiva ipython con la libreria già installata. Per farlo apriamo un altro terminale e digitiamo:\n$ cd odoo.dockerenv/ $ docker-compose run odoo ipython  Ci comparirà quindi il seguente output:\nodoo.dockerenv (completed) $ docker-compose run odoo ipython Starting odoodockerenv_postgres_1 ... done Python 3.5.3 (default, Jan 19 2017, 14:11:04) Type 'copyright', 'credits' or 'license' for more information IPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: import odoorpc In [2]: odoorpc Out[2]: \u0026lt;module 'odoorpc' from '/usr/local/lib/python3.5/dist-packages/odoorpc/__init__.py'\u0026gt;  Continua A questo punto siamo in grado di effettuare le nostre chiamate, vediamo nel dettaglio come procedere\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/teoria/",
	"title": "Preambolo",
	"tags": [],
	"description": "",
	"content": "Per apportare modifiche o aggiungere funzionalità ai moduli e alle applicazioni esistenti, Odoo ci mette a disposizione diversi strumenti in base a cosa e dove vogliamo intervenire.\nOdoo ha dai meccanismi interni specifici che si basano sul concetto di Ereditarietà. Tramite questi meccanismi e\u0026rsquo; possibile modificare Modelli esistenti, Viste oppure Dati (come le regole di accesso).\nIn questo capito andremo ad aggiungere una funzionalità all\u0026rsquo;applicazione Todo creata in precedenza. Attualmente ogni utente può lavorare solo sui suoi task, perchè non aggiungere qualche funzionalità di social networking come la possibilità di condividere i task e di commentarli con diversi utenti?\nPer affrontare i meccanismi di eredità implementeremo queste funzionalità in un nuovo modulo che estende quello precedentemente creato.\nQuesto è il nostro piano:\n Estendere il modello TodoTask aggiungendo l\u0026rsquo;utente attualmente in carico Modificare la logica applicativa per far si che ogni utente lavori solo sui task di cui è incaricato Estendere le viste per aggiungere i campi nessari a quanto sopra Aggingere un wall di messaggi in fondo a ogni Task dove gli utenti possono commentare e seguire (tipo Twitter follow) l\u0026rsquo;evoluzione del task  Per procedere dobbiamo creare un nuovo modulo nella stessa cartella contenente il modulo todo_app. Lo chiameremo todo_user e creeremo al suo interno il file __manifest__.py\n todo_user/ __init__.py __manifest__.py  Nel file di manifesto inseriemo questo contenuto\n{ 'name': 'Multiuser TODO', 'description': 'Estende la Todo app per farla diventare Multi Utente', 'author': 'Fabrizio Arzeni', 'depends': ['todo_app'], }  Notate che abbiamo messo una dipendenza esplicita sul modulo todo_app, questo permettera a Odoo di inizializzare questo modulo dopo aver inizializzato todo_app.\nUn\u0026rsquo;altra differenza è che non abbiamo esplicitato application=True in quanto con questo modulo non andremo a creare una nuova applicazione ma apporteremo solo modifiche a un\u0026rsquo;altra già esistente.\nUna volta fatto questo possiamo aggiornare la lista dei moduli e installare il modulo todo_user nel nostro Odoo.\nA questo punto possiamo andare a vedere come si estende il modello TodoTask\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/preambolo/",
	"title": "Preambolo",
	"tags": [],
	"description": "",
	"content": " Per andare a esplorare cosa possiamo fare con i nostri modelli prepariamoci prima un nuovo modulo che estende gli esistenti. Per analizzare come funzionano le relazioni aggiungeremo anche un paio di modelli.\n TodoProjects progetti per raggruppare i task TodoTag tag per poter classificare i vari task  Abbiamo gia\u0026rsquo; un modulo preparato con queste modifiche, l\u0026rsquo;unica cosa che dobbiamo fare è scaricarlo nella nostra directory addons.\nPer farlo, da terminale, entriamo nella cartella addons\n $ cd addons/  e diamo il comando git per scaricare il modulo\n $ git submodule add https://github.com/metadonors/odoo.workshop.todo_plus.git todo_plus  A questo punto il modulo è disponibile per essere installato, andiamo nella sezione App di Odoo, aggiorniamo la lista e cerchiamo tra i moduli \u0026lsquo;todo\u0026rsquo;\nClicchiamo su Install e navigiamo di nuovo nella nostra app Todo. Notiamo che il nuovo modulo ci ha aggiunto il sottomenu \u0026lsquo;Progetti\u0026rsquo; dove e\u0026rsquo;, appunto, possibile gestire i nostri progetti todo.\nContinua Adesso possiamo cominciare a vedere quali sono i campi base dei modelli Odoo.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/primo_modulo/",
	"title": "Scaffolding",
	"tags": [],
	"description": "",
	"content": " In questa sezione andremo a creare il nostro primo modulo. L\u0026rsquo;applicazione d\u0026rsquo;esempio che creeremo durante il corso è una classica Todo App. Per realizzarla attraverseremo le classiche fasi di sviluppo di un applicazione Odoo.\nLo scheletro del modulo Odoo offre un suo meccanismo di scaffolding piuttosto primitivo per creare nuovi moduli, è possibile visualizzare il suo funzionamento lanciando questo comando dalla cartella contente l\u0026rsquo;ambiente odoo.dockerenv:\n$ docker-compose run odoo odoo scaffold --help  Nella pratica la comunità si è però concentrata su un altro strumento di scaffolding, mrbob con i template specifici per gli addon Odoo.\nVi può essere utile quando affronterete il vostro primo modulo in autonomia, ma durante questo corso creeremo tutta la struttura manualmente in modo da capirne meglio i vari aspetti.\nQuindi cominciamo Un modulo Odoo è una cartella contenente un file __manifest__.py. La cartella deve essere anche un modulo python valido, deve quindi contenere un file __init__.py.\nIl nome della cartella del modulo è un nome tecnico non visibile all\u0026rsquo;utente, deve essere valido in python quindi niente deve cominciare con una lettera e sono validi solo lettere, numeri e underscore. Nel nostro caso useremo quindi il nome todo_app.\nAll\u0026rsquo;interno della cartella addons dell\u0026rsquo;ambiente docker che abbiamo scaricato, creiamo la cartella todo_app con la seguente struttura:\ntodo_app/ __init__.py __manifest__.py  A questo punto è ora di aprire il nostro editor di testo per modificare il file __manifest__.py, dove inseriremo il seguente contenuto:\n{ 'name': 'Applicazione TODO', 'description': 'Gestisci i tuoi TODO', 'author': 'Fabrizio Arzeni', 'depends': ['base'], 'application': True }  Il campo depends indica i moduli da cui dipende la nostra applicazione, se non sono presenti quando verra installata, Odoo li installerà automaticamente. È necessario inserirla soprattutto quando si fa riferimento a funzionalità di terze parti.\nIn questo caso abbiamo usato solo alcuni dei valori definibili nel manifesto di un modulo, nei casi reali questo file è sarà più complesso. Per una spiegazione più dettagliata del suo contenuto potete consultare la pagina della documentazione di Odoo sul file manifest.\nI path degli addon Nel nostro caso Odoo sarà in grado di trovare questa applicazione perchè l\u0026rsquo;abbiamo creata nella cartella addons dell\u0026rsquo;ambiente. Ma quella cartella è stata configurata per essere fra quelle papabili dove Odoo cerca gli addon all\u0026rsquo;avvio. È possibile specificare diversi percorsi dove odoo cerca gli addons disponibili ad essere installati, fate riferimento alla variabile addons-path disponibile sia nel file di confiurazione di odoo che da linea di comando.\nInstallazione del modulo A questo punto è possibile installare il modulo. Come abbiamo fatto nella sezione precedente possiamo andare nella lista delle App, scrive todo nella barra di ricerca e cliccare sul pulsante installa sul nostro modulo.\nMa\u0026hellip;il nostro modulo non c\u0026rsquo;è.\nLa modalità sviluppatore Il nostro modulo non c\u0026rsquo;è perchè Odoo nella sua fase iniziale mette in cache tutti i moduli che sono presenti in quel momento. Per far apparire il nostro modulo dobbiamo dirgli di ricaricare la lista delle applicazioni.\nPer farlo dobbiamo entrare nella modalità sviluppatore che sarà essenziale per tutto il nostro lavoro.\nPer attivarla bisogna andare nell\u0026rsquo;applicazione \u0026lsquo;Settings\u0026rsquo; e premere sulla scritta \u0026lsquo;Activate the developer mode\u0026rsquo; presente sulla destra sotto la versione di Odoo.\nUna volta fatto possiamo tornare nella lista delle App e a questo punto sarà presente il bottone \u0026lsquo;Update App List\u0026rsquo;. Premetelo e rieffettuate la ricerca del modulo todo che dovrebbe essere ora disponibile per essere installato\nCliccate su installa ed il primo passo è compiuto\nNota bene Sviluppare moduli è un processo iterativo e spesso dopo dei cambiamenti, in particolare sul database, sarà necessario riavviare odoo dicendogli esplicitamente di aggiornare i moduli interessati. Se la modifica invece è solo al codice python o a delle viste sarà sufficiente riaggiornare la pagina perchè il sistema è stato lanciato in modalita di sviluppo (con l\u0026rsquo;opzione \u0026ndash;dev=all vedi docker-compose.yml). In fase di produzione qualsiasi aggiornamento comporta il riavvio del sistema\nContinua Ora che abbiamo creato e installato la nostra prima applicazione possiamo continuare andando a modellare i nostri dati definendo Modelli e Campi.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/basics/precorso/",
	"title": "Precorso",
	"tags": [],
	"description": "",
	"content": " Prima di arrivare al corso sarebbe opportuno avere già installati e funzionanti un edito di testo, Git, Docker e Docker Compose\nEditor di testo Non ci sono preferenze per l\u0026rsquo;editor di testo, ovviamente è opportuno usarne uno che aiuti a lavorare con codice python e javascript\nUn elenco di alcuni possibili editor:\n VSCode https://code.visualstudio.com/ Atom https://atom.io/ Sublime Text https://www.sublimetext.com/  Git L\u0026rsquo;installazione di Git varia in base al sistema operativo utilizzato, ecco come procedere:\nLinux Su Ubuntu/Debian è sufficiente dare da terminale:\n$ sudo apt install git  Su Redhat/Centos\n$ sudo yum install git  Mac Su mac, se non l\u0026rsquo;avete gia\u0026rsquo; fatto, prima dell\u0026rsquo;installazione di Git bisogna procedere a installare Homebrew (cosa piuttosto importante se si intende sviluppare software)\nAprite un terminale e copia-incollate il seguente comando:\nruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot; brew doctor  Vi chiedera di installare la Command Line Developer Tool di Apple. Cliccate Install per confermare. Una volta terminato premete Invio per terminare l\u0026rsquo;installazione di Homebrew.\nEffettuato queso passaggio potete installare Git da terminale con il comando:\nbrew install git  Windows Su Windows scaricate l\u0026rsquo;applicazione Git for Windows e installatela\nDocker e Docker Compose Docker è uno strumento di pacchetizzazione generico per le nostre applicazioni. Semplifica l\u0026rsquo;installazione di ambienti complessi sia in fase di sviluppo che di produzione. Per noi è utile per riuscire ad avere una piattaforma uguale per tutti su cui lavorare. Il risultato di una pacchettizzazione con Docker è chiamato Container. Un container è a tutti gli effetti un eseguibile che potete lanciare da linea di comando passandogli parametri secondo necessità.\nNon è necessario utilizzare la versione Enterprise (EE), utilizzeremo la Community Edition (CE) che ha tutte le funzionalità necessarie (ma senza la stessa assistenza)\nDocker Compose invece serve a definire e lanciare diversi container in maniera orchestrata. Con compose si utilizza un file di configurazione YAML per definire tutti i servizi di cui è composta la nostra applicazione, per esempio: odoo, il database e il server web. Una volta terminata la configurazione è possibile creare e lanciare tutti i servizi di cui abbiamo bisogno con un singolo comando.\nAnche per questi strumenti l\u0026rsquo;installazione varia in base al sistema operativo usato.\nLinux Docker Per Ubuntu:\nPer prima cosa aggiungete il repository docker ufficiale:\n$ sudo add-apt-repository \\ \u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\u0026quot;  Aggiornate l\u0026rsquo;indice dei pacchetti:\n$ sudo apt-get update  Infine installate l\u0026rsquo;ultima versione di docker:\n$ sudo apt-get install docker-ce  Per le altre distribuzioni e\u0026rsquo; possibile trovare le istruzioni dettagliate nella pagina ufficiale della documentazione di Docker\nDocker Compose Per installare Compose:\nScaricate l\u0026rsquo;eseguibile con il comando:\nsudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose  Aggiungete il permesso d\u0026rsquo;esecuizione al file binario:\nsudo chmod +x /usr/local/bin/docker-compose  Testate l\u0026rsquo;installazione con:\n$ docker-compose --version docker-compose version 1.21.2, build 1719ceb  Mac Docker e Docker Compose Per Mac è sufficiente scaricare l\u0026rsquo;applicazione ufficiale dall\u0026rsquo;Docker Store\nPer maggiori informazioni qui trovate la pagina di documentazione specifica\nWindows Docker e Docker Compose Come per Mac è sufficiente scaricare l\u0026rsquo;applicazione ufficiale dall\u0026rsquo;Docker Store\nPer maggiori informazioni qui trovate la pagina di documentazione specifica\nContinua\u0026hellip; Una volta terminata questa procedura siete pronti ad iniziare il corso installando l\u0026rsquo;ambiete di sviluppo Odoo\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/basics/",
	"title": "Iniziare",
	"tags": [],
	"description": "",
	"content": " Capitolo 1 Iniziare Per imparare è necessario poterci mettere le mani sopra, quindi installiamo il necessario.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/application_logic/usare_orm/",
	"title": "Usare l&#39;ORM",
	"tags": [],
	"description": "",
	"content": " Fino a questo punto abbiamo utilizzato l\u0026rsquo;ORM di Odoo senza scendere nel dettaglio su come funziona. Ora andiamo a vedere quali sono i suoi principali componenti\nDecoratori Abbiamo notato che a molti metodi dei modelli viene applicato un decoratore come @api.multi. Questi decorati hanno lo scopo di istruire il backend su come gestire i metodi rispetto alle API esposte.\nIl decoratore @api.multi viene utilizzato per gestire metodi applicati su dei RecordSet ed è ill decoratore utilizzato più di frequente. Quando a un metodo viene applicato questo decoratore, il self all\u0026rsquo;interno del metodo farà riferimento a un RecordSet cioè a un oggetto rappresentante una lista di entità e solitamente all\u0026rsquo;interno vi sarà un ciclo for per iterare sui vari oggetti.\nAlcuni ci si aspetta che un metodo venga applicato su un solo oggetto, in quel caso è possibile invocare la funzione self.ensure_one() che solleva un eccezione in caso siano presenti più elementi nel recordset corrente. Successivamente a quella chiamata il self può essere considerato un singleton e sarà quindi possibile accedere agli attributi del record corrente direttamente con la notazione puntata (es print(self.name)).\nIl decoratore @api.model invece si utilizza per decorare metodi statici in cui il self non fa rifermento a nessuna entità in particolare. Per coerenza self farà sempre riferimento a un oggetto di tipo recordset ma il suo contenuto diventa irrilevante. Questo tipo di metodi non possono essere richiamati dalle API e quindi non possono essere usati sui bottoni nell\u0026rsquo;interfaccia utente.\nAltri decoratori con scopi più specifici:\n @api.depends(campo1, campo2, \u0026hellip;) è utilizzato dai computed fields per identificare le dipendenze in base a cui scatenare il ricalcolo del valore del campo. @api.constraints(campo1, campo2, \u0026hellip;) è utilizzato per la validazione, la funzione viene invocata ogni volta che si cerca di modificare il valore del campo. @api.onchange(campo1, campo2, \u0026hellip;) è richiamata ogni volta che nella UI vengono modificati i campi elencati nel decoratore. è utile per aggiornare al volo i form con valori dipendendi da altri campi.  La shell di odoo Lanciando il seguente comando, odoo ci presenta un linea di comando interattiva dove possiamo accedere a tutto l\u0026rsquo;ambiente di odoo. E\u0026rsquo; molto comoda per effettuare dei test:\n$ docker-compose run odoo shell In [1]: self Out[1]: res.users(1,) In [2]: self._name Out[2]: 'res.users' In [3]: self.name Out[3]: 'Administrator'  Recordset I metodi principali utilizzabili nei modelli sono quelli disponibili sulla documentazione ufficiale\nInterrogare i modelli Attraverso la variabile self possiamo accedere solamente ai metodi del modello che stiamo attualmente utilizzando. Ma ogni modello ha un variabile env, accesssibile tramite self.env che ci permette di avere un riferimento a qualsiasi modello installato sul sistema. Per esempio self.env[\u0026lsquo;res.parner\u0026rsquo;] restituisce un riferimento al modello dei Partner permettendoci quindi di utilizzare metodi come search o browse su quel determinato set di dati.\nIl metodo search() accetta come paramentro un domain e restituisce un recordset contenente le righe che rispettano le condizioni del dominio. Passando un domain vuoto ([]) si ottengono tutte le righe presenti. Gli altri paramentri accettati da search() sono:\n order e\u0026rsquo; la stringa utilizzata nella clausula ORDER BY della query SQL limit il numero massimo di elementi da restituire nella query offset ingnora i primi n risultati. Combinato con limit serve a gestire la paginazione degli elementi  A volte serve solo contare gli elemneti in un determinato domain, in quei casi è possibile utilizzare la funzione search_count() che accetta gli stessi parametri della search() ma restituisce un intero (e ha un impatto infinitesimale in termini di performance rispetto alla classica search())\nIl metodo browse() prende una lista di ID oppure un singolo ID e ritorna un recordset contenente i record trovati. E\u0026rsquo; molto più performante della search ma richiede la conoscenza degli ID interessati.\nAlcuni Esempi:\nIn [2]: self.env['res.partner'].search([('name','ilike','ad')]) Out[2]: res.partner(3,) In [4]: p = self.env['res.partner'].browse(3) In [5]: p.name Out[5]: 'Administrator'  Operazioni sui recordset I Recordset supportano diverse operazioni. Possiamo per esempio controllare se un elemento è contenuto in un recordset oppure no.\nConsiderando x un singleton e test_recordset un insieme di elementi possiamo scrivere\n x in test_recordset x not in test_recordset  Sono inoltre dissponibili le seguenti proprietà:\n test_recordset.ids restituisce una lista di ID relativa agli elementi contenuti test_recordset.ensure_one() controlla che il recordset sia un singleton altrimenti lancia un eccezione di tipo ValueError test_recordset.filtered(func) ritorna un recordset filtrato secondo la funzione func test_recordset.mapped(func) ritorna una lista di valori mappati secondo la funzione func test_recordset.sorted(func) ritorna un recordset ordinato secondo la funzione func  Manipolazione dei recordset Per aggiungere, togliere o sostituire elementi dai recorset ci sono una serie di operatori che ci possono aiutare. I recordset di per sè sono immutabili ma attraverso questi operatori è possibile generare nuovi recordset modificati partendo da quelli esistenti\nGli operatori di manipolazione sono:\n rs1 | rs2 restituisce l\u0026rsquo;unione dei due recordset, il risultato conterrà tutti gli elementi di entrambi gli insiemi (senza doppioni) rs1 + rs2 restituisce la somma dei due recordset, il risultato conterrà la concatenazione degli elementi di entrambi gli insiemi (possono quindi esserci dei doppioni) rs1 \u0026amp; rs2 restituisce l\u0026rsquo;intersezione dei due recordset, il risultato conterrà solo gli elementi presenti in entrambi gli insiemi rs1 - rs2 restituisce la differenza dei due recordset, il risultato conterrà gli elementi presenti in rs1 ma non presenti in rs2  È inoltre possibile accedere agli elementi dei recordset attverso gli operatori di list Python, queste sono quindi espressioni valide:\n rs[0] il primo elemento del recordset rs[-1] l\u0026rsquo;ultimo elemento del recordset rs[1:] restituisce una copia del recordset senza il primo elemento  Altri operatori:\n rs_ids |= element_id aggiunge element_id al recordset rs_ids se non presente rs_ids -= element_id rimuove element_id al recordset rs_ids se presente  Query SQL E\u0026rsquo; sempre possibile accedere al databse direttametne eseguendo query SQL personalizzate. Nella varibile self.env.cr è disponibile un cursore legato all\u0026rsquo;attuale connessione al db che possiamo utilizzare proprio a questo scopo.\nPer effetturare una query utilizziamo il metodo execute successitamente dobbiamo invocare un\u0026rsquo;altra funzione per ottenerne gli eventuali risultati: - fetchall() restituisce una lista di tuple rappresentanti le righe - dictfetchall() restituisce una lista di dizionari rappresentanti le righe con il nome della colonna utilizzato come chiave\nIn [1]: self.env.cr.execute(\u0026quot;SELECT id, login FROM res_users WHERE login='%s'\u0026quot; % 'admin') In [2]: self.env.cr.dictfetchall() Out[2]: [{'id': 1, 'login': 'admin'}]  Campi Relazionali I campi relazionali possono essere utilizzati con la notazione puntata, esempio:\nIn [14]: self Out[14]: res.users(1,) In [15]: self.company_id Out[15]: res.company(1,) In [16]: self.company_id.name Out[16]: 'My Company' In [17]: self.company_id.currency_id Out[17]: res.currency(1,) In [18]: self.company_id.currency_id.name Out[18]: 'EUR'  Quando dobbiamo scrivere un campo Many2one dobbiamo ricordarci di passare solo l\u0026rsquo;id dell\u0026rsquo;oggetto e non il singleton corrispondente, quindi e\u0026rsquo; corretto\n# CORRETTO In [17]: self.write({'user_id': self.env.user.id})  ma darebbe invece errore\n# SBAGLIATO In [17]: self.write({'user_id': self.env.user})  Quando invece dobbiamo scrivere i campi Many2many oppure One2many esiste una sintassi specifica per farlo. Il valore che dobbiamo passare nella write è una tupla contenente tre valori i cui possibili valori sono:\n (0, _, values) aggiungi un nuovo record creato dal dizionario values (1, id, values) aggiorna gli elementi correlati esistenti con i valori passati nel dizionario values (non può essere usato con il metodo create()) (2, id, _) rimuovi la relazione con l\u0026rsquo;oggetto idenficato da id e poi cancella l\u0026rsquo;oggetto rimosso dal db (3, id, _) rimuovi la relazione con l\u0026rsquo;oggetto idenficato da id e ma non rimuovere l\u0026rsquo;oggetto rimosso dal db (solo Many2many e non durante la create()) (4, id, _) aggiungi l\u0026rsquo;oggetto esistente con id = id (solo Many2many) (5, _, _) rimuovi tutti gli oggetti dalla relazione (solo Many2many) (6, _, ids) sostituisci tutti gli elementi dalla relazione con quelli identificati dagli id ids (equivalente di chimare prima il comando 5 e poi il 4 su tutti gli ids)  "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/views/context_domain/",
	"title": "Context e Domain",
	"tags": [],
	"description": "",
	"content": " Più volte durante il corso siamo inciampati su context e domain. Abbiamo visto che possono essere legati alle azioni, ma anche usati durante le interrogazioni del database. Vediamo più nel dettaglio che cosa sono.\nContext Il context è un dizionario Python contenente dati che vengono mantenuti durante la sessione e che possono essere utilizzati sia dal client per renderizzare diversi componente della UI, sia dal server per modificare la logica applicativa\nNel client ci sono sia informazioni che riguardano strettamente il funzionamento delle pagine, come per esempio l\u0026rsquo;id della risorsa da visualizzare, sia informazioni che possono modficare il comportamento, come per esempio il filtro preselezionato in una Search View.\nA livello di server invece vengono utilizzate informazioni di sessione come lang che influenza la configurazione della lingua selezionata. Inoltre ci è sempre possibile far riferimento al context per aggiungere variabile legate alla nostra logica.\nDomain I domain in Odoo sono utilizzati per filtrare i dati. Utilizzano una sintassi specifica dell\u0026rsquo;ORM di Odoo e sostanzialmente vengono utilizzati per genereare la parte WHERE delle query SQL.\nUn domain è una lista di condizioni, ogni condizione è composta da una tupla\n(\u0026lt;nome_campo\u0026gt;, \u0026lt;operatore\u0026gt;, \u0026lt;valore\u0026gt;)  come per esempio:\n('is_done', '=', False)  Il nome_campo coniene una string che rappresenta il nome del campo, nei casi di campi relazionali si può fare ricorso alla dot-notation per accedere ai campi dell\u0026rsquo;elemento correlato.\nGli opertori disponibili sono:\n =: uguale a !=: diverso da \u0026gt;: maggiore di \u0026gt;=: maggiore o uguale a \u0026lt;: minore di \u0026lt;=: minore o uguale a =?: ritorna True se il valore e\u0026rsquo; None o False, oppure si comporta come = =like: controlla il valore con un pattern. Un _ nel pattern sta per \u0026lsquo;ogni carattere\u0026rsquo;, una % sta per \u0026lsquo;ogni stringa\u0026rsquo; like: simile a =like ma racchiude il valore in %value% not like: la negazione di like ilike: come like ma senza tenere conto di maiuscolo/minuscolo not ilike: la negazione di ilike =ilike: come ilike ma senza tenere conto di maiuscolo/minuscolo in: ritorna vero se il valore e\u0026rsquo; uguale a almneno uno dei valori contenuti nella lista di comparazione not in: ritorna vero se il valore e\u0026rsquo; diverso da tutti i valori contenuti nella lista di comparazione child_of: ritorna vero se e\u0026rsquo; un figlio dell\u0026rsquo;oggetto passato (controllonado il campo speciale parent_id)  Nell\u0026rsquo;espressione dei domini possono essere utilizzati gli operatori logigici or, and e not rispettivamente con i simboli |, \u0026amp;, !. I domini fanno ricorso alla notazione prefissa per esprimere le connessioni logiche.\nPer esempio per dire:\nTutti i todo in stato done oppure tutti i todo assegnati all\u0026rsquo;utente 3 con titolo contenento \u0026lsquo;Odoo\u0026rsquo;\nsi esprime come\n[ '|',('is_done','=',True), '\u0026amp;', ('user_id', '=', 3), ('name','like','Odoo') ]  che puo\u0026rsquo; essere rappresentato come\ngraph TD; C{OR} C -- D{AND} C -- E[Todo in stato done] D -- F[user_id = 3] D -- G[name like Odoo]  "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/api/operazioni/",
	"title": "Operazioni",
	"tags": [],
	"description": "",
	"content": " La documentazione ufficiale ci illustra come procedere ad interrogare le API utilizzando direttamente le librerie XMLRPC disponibili nei vari linguaggi. In questa sezione invece analizziamo come interfacciarci alla nostra applicazione tramite una libreria di più altro livello, che semplifica e ottimizza le nostre chiamate.\nLogin Per effettuare qualsiasi tipo di operazione tramite API è necessario per prima cosa autenticarsi. L\u0026rsquo;autenticazione tramite API avviene utilizzando tre informazioni: username, password e nome del database dei riferimento.\nAbbiamo ovviamente bisogno di conoscere anche indirizzo e porta dove gira il nostro Odoo.\nPer autenticarsi apriamo una shell interattiva con\n$ docker-compose run odoo ipython  e al suo interno scriviamo\nIn [1]: import odoorpc In [2]: odoo = odoorpc.ODOO('odoo',port=8069) In [3]: odoo.login('demo','admin','admin') In [4]: user = odoo.env.user In [5]: print(user.name) Administrator In [6]: print(user.company_id.name) My Company  Nel nostro caso specifico l\u0026rsquo;installazione risponde all\u0026rsquo;indirizzo odoo che abbiamo configurato nel file docker_compose.yml. Nei casi reali corrisponderà all\u0026rsquo;URL della vostra installazione\nLeggere da API Per le operazioni di lettura possiamo utilizzare diverse funzioni, disponibili anche lato backend: browse, search, search_read.\n browser: accetta una lista di id di entità che verranno lette tutte assieme e restituisce degli oggetti rappresentanti le risorse search: accetta un dominio su cui effettuare una ricerca e restituisce gli id degli oggetti trovati (è quindi poi necessario effetturare una chiamata browse per ottenerne il contenuto) search_read: accetta un dominio e un elenco di attributi e restituisce dei dizionari contenenti solo i valori richiesti  Le due funzioni di ricerca accettano anche i parametri offset e limit su cui si può impostare la paginazione.\nDal momento che le richieste API viaggiano su chiamate di rete che sono notoriamenet lente, la funzione search_read acquista una notevole importanza perchè ci permette di ottimizzare i payload che dovranno poi essere scambiati fra gli endpoint, facendoci restituire solo il necessario.\nBrowse Per effettuare una chiamata browse ed accedere alle risorse tramite il loro id, procediamo in questo modo\nIn [10]: todo = odoo.env['todo.task'].browse(3) In [11]: todo.name Out[11]: 'WorkShop su Odoo'  Search Per effettuare una chiamata browse ed accedere alle risorse tramite il loro id, procediamo in questo modo\nIn [12]: todos = odoo.env['todo.task'].search([('name','ilike','odoo')]) In [13]: todos Out[13]: [3]  Search_Read Per effettuare una chiamata browse ed accedere alle risorse tramite il loro id, procediamo in questo modo\nIn [15]: todos = odoo.env['todo.task'].search_read([('name','ilike','odoo')], ['id', 'name','description']) In [16]: todos Out[16]: [{'description': '\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;Un interessante descrizione\u0026lt;/b\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;', 'id': 3, 'name': 'WorkShop su Odoo'}]  Creazione di record Per creare nuovi oggetti possiamo ricorrere alla funzione create\nIn [15]: todo_id = odoo.env['todo.task'].create({'name': 'Test da API', 'description': 'Sono un test creato da API'}) In [16]: todo_id Out[16]: 7  Modifica dei record Per modificare oggetti esistenti ricorrere alla funzione write, su un oggetto resistuito da browse\nIn [20]: todo = odoo.env['todo.task'].browse(3) In [21]: todo.write({'name': 'Nuovo titolo'}) Out[21]: True  Cancellazione dei record Per cancellare oggetti esistenti ricorrere alla funzione unlink\nIn [27]: odoo.env['todo.task'].unlink(3) Out[27]: True  Oppure con un approccio Active Record\nIn [20]: todo = odoo.env['todo.task'].browse(3) In [21]: todo.unlink() Out[21]: True  Altre funzioni Ogni volta che dichiariamo un metodo con il decoratore @api.multi o @api.model quello che stiamo facendo è effettivamente dichiarare un nuovo endpoint API su quel modello. Come unica restrizione di sicurezza Odoo non permette a client diversi da il proprio client web di chiamare le funzioni che iniziano con \u0026ldquo;_\u0026rdquo;.\nPer esempio:\n@api.model def io_posso_essere_chiamata_da_client_esterni(self): return \u0026quot;OK\u0026quot; @api.model def _io_non_posso_essere_chiamata_da_client_esterni(self): return \u0026quot;KO\u0026quot;  Permette di effetturare una chiamata API come questa\nIn [20]: todo = odoo.env['todo.task'].browse(3) In [21]: todo.io_posso_essere_chiamata_da_client_esterni() Out[21]: \u0026quot;OK\u0026quot;  "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/campi_base/",
	"title": "Campi Base",
	"tags": [],
	"description": "",
	"content": " L\u0026rsquo;ORM di Odoo permette di creare modelli complessi composti da attributi basa su tipi di campi semplici. Questi campi mappano direttamente sul database e, in base al tipo, possono avere comportamenti differenti a livello di interfaccia utente. I campi di testo verranno renderizzati come semplici tag \u0026lt;input\u0026gt;, le date presenteranon un calendario, le selezioni multiple un tag \u0026lt;select\u0026gt; e così via.\nTipi di Campi Ogni tipo di campo ha può accettare una serie di parametri che variano il suo comportamento. Per il dettaglio completo delle loro specifiche rimandiamo alla documentazione ufficiale di Odoo.\nDi seguito facciamo una panoramica dei principale di di campi non relazionali che possono essere utilizzati:\n Char: è il campo base per rapresentare valori testuali. Può accettare come argomento la lunghezza massima. Text: a livello di database è identico al campo Char, ma viene renderizzato come un input multilinea a livello di interfaccia utente. Selection: rappresenta un campo testo con un predertiminato insieme di valori, viene presentato all\u0026rsquo;utente con un menù a tendina. Html: a livello di database è identico al campo Char, ma all\u0026rsquo;utente viene presentato con un editor WYSWYG che traduce direttamente in HTML e il suo input viene pulito per ragioni di sicurezza prima di essere salvato. Integer: rappresenta volari numerici interi. Float: rappresenta volari numerici in virgola Date e Datetime: vengono salvati in database come stringhe nel formato YYYY-MM-DD, all\u0026rsquo;utente ddi solito sono presentati con un calendario per semplificare l\u0026rsquo;inserimento Boolean: può assumere i valori True o False e viene rappresentato con una checkbox Binary: serve a salvare file direttamente i database. Il contenuto del file viene salvato in base64  Argomenti dei tipi di campo Quando viene dichiarato un campo è possibile, a volte necessario, passargli degli argomenti. Alcuni tipi di campo hanno argomenti specifici per cui rimandiamo alla documentazione, ma altri sono piuttosto comuni e utilizzati spesso:\n string: l\u0026rsquo;etichetta utilizzata di default per il campo default: il valore di default da attribuire al campo alla creazione help: una stringa di supporto all\u0026rsquo;utente che viene visualizzato come tooltip sopra il campo readonly=True: rende il campo non scrivibile da interfaccia utente, rimane comunque possibile modiificaro programmaticamente required=True: rende il campo obbligatorio sia da interfaccia che da codice (la colonna sul database diventa NOT NULL) index=True: crea un indice sulla collonna del database copy=False: il campo viene ignorato quando si utilizza la funzione di copia del framework groups: un elenco dei gruppi abilitati a vedere e utilizzare il campo  Meritano di essere citati anche:\n deprecated=True: crea un WARNING log sulle applicazioni che stanno ancora utilizzando questo campo oldname=\u0026lsquo;old_field: si usa quando si rinomina un campo, questo permette ad Odoo di migrare i dati del database sulla nuova colonna  Nomi di Campi riservati Alcuni nomi di campi non vanno utilizzati perchè vengono automaticamente istanziati da Odoo:\n id: la chiave primaria della tabella create_date: data e ora di creazione del record create_uid: utente che ha creato il record write_date: data e ora di ultima modifica del record wirte_uid: utente che ha effettuato l\u0026rsquo;ultima modifica al record  Nomi di Campi particolari Altri nomi di campi vengono utilizzati dal framework per sveltire alcune operazioni, non è quindi oppurtuno utilizzarli in contesti diversi da quello per cui sono stati pensati:\n name: è usato di default come nome da visualizzare per il record. active (tipo Boolean): viene utilizzato per effettuare un soft-delete del record. I record con active=False vengono automaticamente esclusi dalle query a meno di non specificare la codizione nel domain della query stessa sequence (tipo Integer): se presente viene utilizzato come indice per ordinare le righe nelle List View state (tipo Selection): rappresenta gli stati del ciclo di vita del record e può essere usato da altri campi per decidere quando essere visibili/leggibili/obbligatori o meno.  Nella pratica Andiamo a modificare il nostro modello TodoTask arricchendolo con nuovi campi (e nuovi tipi di campo) così da vedere nella pratica come vengono utilizzati.\nApriamo il file models/todo_task.py del modulo todo_plus/ e modifichiamo la classe di conseguenza:\nclass TodoTask(models.Model): _inherit = 'todo.task' state = fields.Selection([ ('draft', 'Bozza'), ('progress', 'In Corso'), ('completed', 'Completato'), ('canceled', 'Annullato'), ], string='Stato', default='draft') completed_date = fields.Datetime(string='Data Completamento', states={ 'completed': [('readonly', True)], 'canceled': [('readonly', True)] }) worked_hours = fields.Float(string='Ore lavorate') description = fields.Html(string='Descrizione') internal_notes = fields.Text(string='Note interne')  Aggiungiamo questi campi alle nostre viste, nel file views/todo_task.xml\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_form_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_app.todo_task_form_view\u0026quot;/\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;!-- in fondo al tag header aggiungi un widget per rappresentare il campo state --\u0026gt; \u0026lt;header position=\u0026quot;inside\u0026quot;\u0026gt; \u0026lt;field name='state' widget='statusbar' clickable=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- dopo il campo deadline_date aggiungi i campi completed_date e worked_hours --\u0026gt; \u0026lt;field name='deadline_date' position='after'\u0026gt; \u0026lt;field name='completed_date'/\u0026gt; \u0026lt;field name='worked_hours' /\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;!-- dopo il group di nome 'group_top' aggiungi un nuovo group con il campo descrizione --\u0026gt; \u0026lt;group name=\u0026quot;group_top\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026quot;description\u0026quot;/\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  A questo punto sarà necessario effettuare l\u0026rsquo;upgrade del nostro modulo\n $ docker-compose run odoo upgrade todo_plus  Ricaricare la pagine e ottenere un form con questo aspetto\nContinua Dei modelli isolati però non sono molto utili vedimamo quindi come lavorare con i campi relazionali\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/estendere_modelli/",
	"title": "Estendere i Modelli",
	"tags": [],
	"description": "",
	"content": " In Odoo i nuovi modelli, o le estensioni di quelli esistenti, si creano definendo delle classi Python specifiche. Il meccanismo di ereditarietà di Odoo non si base su quello delle classi Python, ma su un suo approccio interno che si basa sull\u0026rsquo;attributo _inherit specificato nella class.\nIn base a come viene utilizzato si possono ottenere differeneti meccanismi di ereditarietà.\nNoi cominceremo con il più semplice dove la classe figlia eredita tutte le funzionalità del padre e dove noi possiamo semplicemente apportare le modifiche che ci interessano.\nPer prima cosa andiamo a creare la cartella models/ con il file __init__.py e il file todo_task.py che ospiterà le nostre modifiche, ottenendo questa struttura:\n todo_user/ models/ __init__.py todo_task.py __init__.py __manifest__.py  Inseriamo gli import necessari per far funzionare il codice Python mettendo all\u0026rsquo;interno del file todo_user/__init__.py\nfrom . import models  e all\u0026rsquo;interno del file todo_user/models/__init__.py\nfrom . import todo_task  Aggiungere campi a un modello A questo punto siamo pronti a modificare il file todo_task.py per estendere il nostro precedente modello. Aprimo il file e scriviamo quanto segue\n# -*- coding: utf-8 -*- from odoo import models, fields, api class TodoTask(models.Model): _inherit = 'todo.task' user_id = fields.Many2one('res.users', 'Assigned to') deadline_date = fields.Date('Deadline')  Come vedete non c\u0026rsquo;è nessun meccanismo python di eredità e anche il nome della classe è irrilevante a questi fini. Il punto chiave è l\u0026rsquo;attributo _inherit che dice ad Odoo di estendere il modello todo.task. Le altre linee sono normali dichiarazioni di campi.\nModificare campi esistenti Aggiungere campi è piuttosto semplice, ma è anche possibile apportare modifiche a campi esitenti. Per farlo è sufficiente ridichiara il campo e passare solo gli attributi che si vogliono andare a modificare.\nPer esempio per modificare il tooltip del campo name possiamo aggiungere il campo\nname = fields.Char(help=\u0026quot;Cosa bisogna fare?\u0026quot;)  Per vedere se le modifiche che abbiamo apportato sono corrette dobbiamo effettuare l\u0026rsquo;upgrade del modulo todo_user, ricaricare la pagina e controllare che il tooltip presente nella Form View dei Todo Task sia aggiornata con quando abbiamo scritto, come nell\u0026rsquo;immagine che segue\nModificare i metodi del modello Con l\u0026rsquo;eredità dei modelli, oltre ai campi, è posssibile anche i metodi associati. Aggiungere un nuovo metodo è semplice: è sufficiente dichiarare una nuova funzione. Se invece si vuole modificare il comportamento di un metodo esistente, si può procedere sovrascrivendo il metodo stesso ed è possibile, se necessario, invocare comunque il metodo padre con la funzione super() di Python.\nCambiare gli argomenti dei metodi esistenti può essere pericoloso perchè non potete sapere chi li sta già invocando. In caso sia necessario è opportuno inizializare gli argomenti con un valore predefinito.\n Nel nostro caso vogliamo che quando un utente invoca il metodo do_clear_done non vengano chiusi tutti i task completati ma solo quelli assegnati all\u0026rsquo;utente stesso oppure quelli non assegnati.\nPer farlo aggiungiamo il seguente metodo all\u0026rsquo;oggetto TodoTask nel file models/todo_task.py\n@api.multi def do_clear_done(self): dones = self.search([ ('is_done', '=', True), '|', ('user_id', '=', self.env.uid), ('user_id', '=', False) ]) dones.write({'active': False})  Vediamo invece come estendere un metodo, senza sovrascrivere completamente la logica presente nel modello originale. Per la funzione do_toggle_done vogliamo aggiungere un controllo in caso l\u0026rsquo;utente stia cercando di chiudere un task che non gli è assegnato. In quel caso lanciamo un errore, altrimenti procediamo come consueto.\nPer ottenere questo comportamente modifichiamo il file models/todo_task.py, aggiungendo neglle importazioni iniziali\nfrom odoo.exceptions import ValidationError  e nel corpo della classe il metodo\n@api.multi def do_toggle_done(self): for task in self: if tast.user_id != self.env.user: raise ValidationError(\u0026quot;Solo l'incaricato può chiudere questo task\u0026quot;) return super(TodoTask, self).do_toggle_done()  Continua A questo punto per poter testare queste modifiche è necessario apportare delle modifiche alle viste di questo modello estendendo le Viste\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/primo_modello/",
	"title": "I modelli",
	"tags": [],
	"description": "",
	"content": " Ora che abbiamo la nostra prima applicazione iniziamo ad aggiungere un semplice modello.\nI modelli sono la M del paradigma MVC, rappresento i dati su cui la nostra applicazione lavora. Sono dei modelli i Prodotti, le Fatture, i Clienti, etc.\nI modelli sono descritti da classi Python che ereditano da una classe generica del framework Odoo le loro funzionalità base. Il loro compito principale è quello di tradurre il loro schema sulle tabelle del database. Odoo si occuperè poi automaticamente di installare e aggiornare il database in fase di upgrade del modulo.\nIl nostro primo modello Il modello che andremo a definire è un semplice Todo Task, ogni task avrà un campo testo per la descrizione e un campo booleano per segnare il task come completato.\nCreazione del modello Tutti i modelli di un modulo risiedono all\u0026rsquo;interno di una cartella models all\u0026rsquo;interno del modulo, e al suo interno aggiungiamo il file todo_model.py e il file __init__.py, necessario per far capire a Python che il contenuto di models è importabile.\nAvremo cosi questa struttura:\n todo_app/ models/ __init__.py todo_model.py __init__.py __manifest__.py  All\u0026rsquo;interno del file del modello todo_model.py aggiungiamo questo contenuto:\n# -*- coding: utf-8 -*- from odoo import models, fields class TodoTask(models.Model): _name = 'todo.task' _description = 'Todo Task' name = fields.Char('Description', required=True) is_done = fields.Boolean('Done?') active = fields.Boolean('Active?', default=True)  A questo punto Odoo non sa ancora dell\u0026rsquo;esistenza della nostra cartella dei modelli, ne che e\u0026rsquo; stato definito un file todo_models.py. Per rendere la nostra modifica effettiva dobbiamo aggiustare le importazioni dei file negli __init__.py\nAll\u0026rsquo;interno del file _todo_app/__init__.py aggiungiamo:\nfrom . import models  All\u0026rsquo;interno del file _todo_app/models/__init__.py aggiungiamo:\nfrom . import todo_model  A questo punto Odoo sarà in grado di riconoscere e manipolare il modello appena creato.\nUpgrade del modulo Ogni volta che effettuiamo una modifica ad un modello, dobbiamo dire manualmente ad odoo di aggiornare (migrare) il database, per farlo abbiamo un comando apposito da passare ad odoo.\nApri una nuova shell e dalla cartella contentente il fiel docker_compose.yml, scrivi:\n$ docker-compose run odoo upgrade todo_app  Che fra le tante cose che scrive, dovrebbe anche dire:\n2018-06-28 09:46:34,017 1 INFO demo odoo.modules.registry: module todo_app: creating or updating database tables  Controllare il modello Attualmente non abbiamo ancora definito nè viste nè modelli, quindi non ci è possibile vedere semplicemente se le modifiche sono state apportate al sistema. Abbiamo un ottima occasione però per vedere un altro strumento di sviluppo che Odoo ci offre. Attiviamo la modalità sviluppatore e andiamo nel modulo:\nSettings -\u0026gt; Technical -\u0026gt; Database Structure -\u0026gt; Models\nCerchiamo il modello todo.task e sulla lista clicchiamo sul risultato ottenuto. Se tutto è andato dovremmo vedere una schermata tipo questa:\nChe ci conferma che il modello e i campi che abbiamo definito sono stati effettivamente creati. Come vede Odoo si occupa automaticamente di aggiungere altri campi, tra cui i più rilevanti sono:\n id è l\u0026rsquo;identificatore unico numerico assegato a ogni istanza del nostro modello create_date e create_uid specificano quando e chi ha creato l\u0026rsquo;istanza write_date e write_uid specificano quando e chi ha modificato l\u0026rsquo;istanza  Questi campi vengono aggiunti automaticamente a tutti i modelli che verranno creati.\nContinua Adesso che abbiamo un modello di dati su cui lavorare possiamo creare le prime viste che ci permettarann di interagire con il database tramite l\u0026rsquo;interfaccia web.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/",
	"title": "La prima applicazione",
	"tags": [],
	"description": "",
	"content": " Chapter 2 La prima applicazione Odoo è un framework MVC, i Modelli sono la M del paradigma e ci permettono di rappresentare i nostri dati in maniera strutturata, come per esempio i Prodotti, le Vendite, le Fatture o i Clienti. La C sta per controller che rappresenta la parte funzionale dei nostri dati. La V invece sono le viste, i componenti che descrivono l\u0026rsquo;interfaccia utente.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/basics/installazione/",
	"title": "Installazione",
	"tags": [],
	"description": "",
	"content": " Una volta installati gli strumenti di sviluppo come descritto nella sezione Precorso possiamo procedere ad installare l\u0026rsquo;ambiente di odoo che utilizzeremo in questo corso.\nInstallazione dell\u0026rsquo;ambiente di sviluppo Scaricate l\u0026rsquo;ambiente docker che utilizzeremo dal github in una cartella sul nostro computer. Aprite un terminale e digitate:\n$ git clone https://github.com/metadonors/odoo.docker.git  Entriamo nella cartella appena scaricata:\n$ cd odoo.docker  Infine diciamo a compose di tirare su l\u0026rsquo;ambiente:\n$ docker-compose up  Compose comincerà a scaricare tutte le nostre dipendenze, odoo, nginx e il database. La procedura può metterci diversi minuti in base alla connessione a internet disponibile.\nIn seguito verranno avviati i vari componenti: odoo, postgres - il database - e nginx - il server web. Al primo avvio odoo dovrà inizializzare la struttura del database (anche questa operazione potrebbe impiegare qualche minuto).\nUna volta terminata, aprite il vostro browser all\u0026rsquo;indirizzo:\nhttp://localhost\ndovreste vedere la schermata di accesso di Odoo. Per entrare inserite le credenziali predefinite:\nUsername: admin Password: admin\nContinua\u0026hellip; Una volta terminata l\u0026rsquo;installazione possiamo affrontare i concetti base\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/views/form_view/",
	"title": "Form View",
	"tags": [],
	"description": "",
	"content": " Struttura Le applicazioni Business-oriented spesso sono costituite da insiemi di record - i rpodotti in magazzino, le fatture della contabilità, etc. La maggior parte di questi tipi di dati può essere rappresentato come un documento di carta. Odoo quindi riutilizza questa astrazione per rappresentare i suoi record.\nQuesta è la struttura generale di un record Odoo\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_form_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;form string=\u0026quot;ToDo task Form\u0026quot;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- Sezione dedicata ai pulsanti e al widget dello stato del record --\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;sheet\u0026gt; \u0026lt;!-- Sezione dedicata al contenuto del form --\u0026gt; \u0026lt;/sheet\u0026gt; \u0026lt;div class='oe_chatter'\u0026gt; \u0026lt;!-- Storico e comunicazioni --\u0026gt; \u0026lt;div class=\u0026quot;oe_chatter\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;message_follower_ids\u0026quot; widget=\u0026quot;mail_followers\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;message_ids\u0026quot; widget=\u0026quot;mail_thread\u0026quot;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Quindi come si vede ogni documento Odoo è costituito da tre aree principali: \u0026lt;header\u0026gt; dedicato al ciclo di vita del record, \u0026lt;sheet\u0026gt; per il corpo del record e infine una sezione dedicata allo storico e alle comunicazioni chiamato solitamente chatter.\nL\u0026rsquo;intestazione: \u0026lt;header\u0026gt; Nell\u0026rsquo;header solitamente sono presenti due tipi di entità: pulsanti e statusbar. I pulsanti sono normali tag \u0026lt;button\u0026gt; e solitamente l\u0026rsquo;azione principale viene evidenziata passandogli la classe css oe_highlight.\nLa statusbar invece solitamente fa riferimento all\u0026rsquo;attributo state dell\u0026rsquo;oggetto. L\u0026rsquo;attributo state può essere o una semplice Selection di stati oppure un campo Many2one. Nel secondo caso parliamo di Stage del record. In entrambi i casi però gli attributi possono essere rappresentati con il widget statusbar.\n\u0026lt;header\u0026gt; \u0026lt;!-- Aggiungiamo un pulsante per modificare lo stato Fatto del task --\u0026gt; \u0026lt;button name=\u0026quot;do_toggle_button\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Toggle Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt; \u0026lt;!-- Aggiungiamo un pulsante per rimuovere i task in stato fatto --\u0026gt; \u0026lt;button name=\u0026quot;do_clear_done\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Clear All Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt; \u0026lt;field name='state' widget='statusbar' clickable=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/header\u0026gt;  Il Corpo: \u0026lt;sheet\u0026gt; Il tag \u0026lt;sheet\u0026gt; è l\u0026rsquo;area principale dedicata alla presentazione dei date. È disegnata in modo da rappresentare un foglio di carta e solitamente è suddivisa in questi componenti:\n Titolo e sottotitolo in alto Un box di bottoni nella parte superiore (smart buttons) Un\u0026rsquo;area con i campi principali del docuemnto Una sezione organizzata in tab (notebook)  Titolo e sottotitolo All\u0026rsquo;interno delle viste XML oltre ai tag specifici di Odoo è possibile utilizzare anche i normali tag html. Per esempio per renderizzare l\u0026rsquo;area dedicata a titolo e sottotitolo si fa ricorso a un normale \u0026lt;div\u0026gt; di class oe_title. Per esempio\n\u0026lt;sheet\u0026gt; \u0026lt;div class=\u0026quot;oe_title\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;name\u0026quot; class=\u0026quot;oe_edit_only\u0026quot;/\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;span class=\u0026quot;oe_read_only\u0026quot;\u0026gt;By\u0026lt;/span\u0026gt; \u0026lt;label for=\u0026quot;user_id\u0026quot; class=\u0026quot;oe_edit_only\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot; class=\u0026quot;oe_inline\u0026quot;/\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Il resto del contenuto del docuemnto --\u0026gt; \u0026lt;/sheet\u0026gt;  Gli smart buttons La zona in alto a destra del documento è dedicato al contenitore degli smart buttons. Sono dei normali bottoni con un estetica dedicata che solitamente contegono informazioni statistiche o contatori e un rimando ai dati che rappresentano.\nPer creare un contenitore per questi bottoni si può aggiungere a fianco all\u0026rsquo;eventuale oe_title un altro div di class oe_button_box\n\u0026lt;div name=\u0026quot;buttons\u0026quot; class=\u0026quot;oe_right oe_button_box\u0026quot;\u0026gt; \u0026lt;!-- L'elenco di smart buttons --\u0026gt; \u0026lt;/div\u0026gt;  Raggruppare i campi Il contentuno principale dei form può essere organizzato utilizzando il tag \u0026lt;group\u0026gt;. Questo tag crea due colonne nella sua area e, di default, i field conenuti vengono rappresentati con la loro label.\nSe presente un solo tag \u0026lt;group\u0026gt; i \u0026lt;field\u0026gt; contenuti occuperanno due colonne, una per la label e l\u0026rsquo;altra per l\u0026rsquo;input. Se invece vengono aggiunti altri tag \u0026lt;group\u0026gt;, i field e le loro label saranno distribuiti su altre due colonne.\n\u0026lt;group name=\u0026quot;group_top\u0026quot;\u0026gt; \u0026lt;group name=\u0026quot;group_left\u0026quot;\u0026gt; \u0026lt;!-- label + field nella colonna di sinistra --\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; [...] \u0026lt;/group\u0026gt; \u0026lt;group name=\u0026quot;group_right\u0026quot;\u0026gt; \u0026lt;!-- label + field nella colonna di destra --\u0026gt; \u0026lt;field name=\u0026quot;deadline_date\u0026quot;/\u0026gt; [...] \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt;  Il notebook Un altro strumento per organizzare i contenuti nei nostri form e\u0026rsquo; l\u0026rsquo;elemento \u0026lt;notebook\u0026gt; che contiene al suo interno altri elementi chiamati pagine. E\u0026rsquo; molto utile per organizzare i dati meno utilizzati in sottosezioni facilmente raggiungibili.\nUn esempio di notebook:\n\u0026lt;notebook\u0026gt; \u0026lt;page string=\u0026quot;Info\u0026quot; name=\u0026quot;info\u0026quot;\u0026gt; \u0026lt;!-- contenuto prima pagina --\u0026gt; \u0026lt;field name=\u0026quot;other_info\u0026quot;/\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;page string=\u0026quot;Info 2\u0026quot; name=\u0026quot;info2\u0026quot;\u0026gt; \u0026lt;!-- contenuto seconda pagina --\u0026gt; \u0026lt;/page\u0026gt; [...] \u0026lt;/notebook\u0026gt;  Componenti Odoo fornisce una serie di componenti aggiuntivi al normale HTML, con funzionalità di più alto livello.\nFields I fields vengono utilizzati per rappresentare e manipolare i dati dei modelli. Prendono una serie di attributi che solitamente vengono specificati nella dichiarazione del campo nel modello ma che possono essere sovrascritti nella vista:\nI principali attributi dei campi:\n name: identifica il nome dell\u0026rsquo;attributo di riferimento string: il testo della label implicita utilizzata per il campo help: testo mostrato in un tooltip sull\u0026rsquo;etichetta del campo quando il curore ci si ferma sopra placeholder: un suggerimento da visualizzare all\u0026rsquo;utente all\u0026rsquo;interno del campo widget: sovrascrive il tipo di wiget da utilizzare per visualizzare il campo options: un dizionario di opzioni da passare eventualmente al widget nolabel=True: disabilita la presentazione automatica della label del campo invisible=True: nasconde il campo, ma i dati relativi sono comunque caricati e disponibili nel form readonly=True: rende il campo non modificabile required=True: rende il campo obbligatorio  Label per i Fields Il tag \u0026lt;label\u0026gt; può essere utilizzato per un maggior controllo sulla visualizzazione dell\u0026rsquo;etichetta del campo. Un classico è quello di far visualizzare l\u0026rsquo;etichetta solo in modalità modifica utilizzando la classe CSS oe_edit_only\n\u0026lt;label for=\u0026quot;name\u0026quot; class=\u0026quot;oe_edit_only\u0026quot; /\u0026gt;  Relational Fields Anche i campi relazionali hanno alcune opzioni specifiche che ne modificano il comportamento. Di default attraverso un campo relazionale l\u0026rsquo;utente potrà creare, e visualizzare i dati dei modelli collegati. Per disabilitare questa funzione è possibile utilizzare l\u0026rsquo;attributo options\n\u0026lt;field name=\u0026quot;project_id\u0026quot; options=\u0026quot;{'no_open': True, 'no_create': True}\u0026quot;/\u0026gt;  Anche context e domain sono molto utili con i campi relazionali. Attraverso il context è posibile passare valori di default alla creazione di un oggetto collegato, mentre con il domain è possibile filtrare a priori i possibili valori che l\u0026rsquo;oggetto correlato può avere.\nWidget per i Fields Ogni tipo di campo viene visualizzato nel form con un widget di default, ma è possibile comunque sovrascrivere questo comportamento utilizzando altri widget (o creandone di specifici) all\u0026rsquo;occorrenza.\nPer i campi testuali, abbiamo già disponibili questi widget:\n email renderizza il valore del campo come un link di tipo mailto url renderizza il valore del campo com un link html renderizza il campo come html, in fase di modifica presente un editor WYSWYG  Per i campi numerici, abbiamo già disponibili questi widget:\n handle utilizzato di solito con i campi che indicano la posizione, renderizza un\u0026rsquo;icona che permette il drag and drop dei record nelle liste float_time renderizza un campo float come ore:minuti monetary renderizza un campo fload con il relativo valore di valuta. Si aspetta anche un opzione currency_id che indica quale attributo del modello utilizzare per indicare la valuta corrente proggressbar renderizza un float come una barra di progresso e il valore espresso in %  Per i campi relazionalie e i Selection, abbiamo già disponibili questi widget:\n many2many_tags renderizza il campo come una lista di label simili a bottoni selection renderizza il campo con un menu a tendina radio rederizza il campo con una lista di radio buttons priority rappresenta il campo con una lista di stelline cliccabili (solitamente i valori in questo caso sono numerici)  Button I tag \u0026lt;label\u0026gt; accettano questo tipo di attributi:\n icon un\u0026rsquo;icona da utilizzare all\u0026rsquo;interno del bottone, le uniche disponibili sono quelle presenti nella cartella addons/web/static/src/img/icons/ string il testo da visualizzare all\u0026rsquo;interno del bottone type indica il tipo di azione che verrà scatenata alla pressione del pulsante  object è utilizzata per invocare un metodo python action è utilizzata per invocare una window action  name identifica l\u0026rsquo;azione specifica da invocare. Sarà quindi o il nome del metodo o l\u0026rsquo;XMLID della window action args quando il type è object, questo attributo viene usato per passare argomenti al metodo context aggiunge valori al context confirm visualizza una schermata di conferma con un messaggio il cui testo è quello assegnato a questo attributo special=\u0026ldquo;cancel\u0026rdquo; usato nei wizard, si usa sul bottone che annulla l\u0026rsquo;operazione  "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/relazioni/",
	"title": "Relazioni",
	"tags": [],
	"description": "",
	"content": " Abbiamo visto come lavoare con tipi di campi non relazionali, ma nelle applicazioni reali una buona parte delle strutture dati descrivono relazioni fra le entità. L\u0026rsquo;ORM di Odoo è in grado di gestire i vari tipi di relazioni fra oggetti, mettendo a disposizione un set di funzionalità pronte all\u0026rsquo;uso.\nPer avere chiaro cosa stiamo per fare, chiariamo cosa vogliamo costruire. Finora abbiamo lavorato con l\u0026rsquo;oggetto TodoTask. Adesso aggiungeremo il modello TodoProject che raggruppa i Task, e il modello TodoTag che li classifica. Ogni TodoTask può appartenere a un solo progetto, c\u0026rsquo;è quindi una relazione N a 1 fra di loro. Stessi tag possono invece essere assegnati a diversi TodoTask, avranno quindi una relazione N a N tra di loro.\nRealazioni Many2one Nel caso della relazione fra progetti e task abbiamo detto che esiste una relazione Molti a uno (o Uno a molti guardandola dall\u0026rsquo;altra parte). Per aggiungere questo tipo di relazione in odoo possiamo ricorrere al tipo di campo Many2one.\nApriamo quindi il file models/todo_task.py contenente il nostro modello TodoTask e aggiungiamo questo campo alla classe:\nproject_id = fields.Many2one('todo.project', string='Progetto')  Successivamente apriamo il nostro views/todo_task.xml e aggiungiamolo anche alla vista form:\n\u0026lt;!-- All'interno del campo arch aggiungiamo --\u0026gt; \u0026lt;field name='name' position='after'\u0026gt; \u0026lt;field name='project_id'/\u0026gt; \u0026lt;/field\u0026gt;  Aggiorniamo il modulo\n $ docker-compose run odoo upgrade todo_plus  e ricarichiamo la pagina\nOdoo ha aggiunto il nostro campo Many2one che ci permette di selezionare progetti esistenti oppure aprire un la From View dei progetti per crearne uno nuovo da agganciare.\nRealazioni One2many Considerando invece la relazione dal punto di vista opposto, quello dei progetti, la relazione è inversa: ogni TodoProject sarà legato a tanti oggetti TodoTask. Questo tipo di relazione in Odoo è chiamata One2many. Per definirla è necessario definire nella dichiarazione del campo su quale attributo dell\u0026rsquo;oggetto figlio avviene la relazione. Uno stesso oggetto potrebbe avere più relazioni One2many verso la stessa classe di oggetti.\nPer aggiunger questa relazione al nostro modello dei progetti aprima il file models/todo_project.py e aggiungiamo nel corpo della classe:\ntodo_ids = fields.One2many('todo.task', 'project_id', string='Todos')  Per convenzione su Odoo i nomi dei campi relazionali vengono sempre terminati con _id o _ids. Questo per indicare velocemente agli sviluppatori se si tratta di una relazione a uno oppure a molti. Consiglio vivamente di continuare con questa convenzione.\n E nel file delle viste dei progetti views/todo_project.xml aggiungiamo questo record:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_project_form_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.project.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.project\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;form string=\u0026quot;ToDo Project Form\u0026quot;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;field name='state' widget='statusbar'/\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;sheet\u0026gt; \u0026lt;!-- Raggruppiamo i campi su due colonne e assegnamo un identificativo ai vari gruppi --\u0026gt; \u0026lt;group name=\u0026quot;group_top\u0026quot;\u0026gt; \u0026lt;group name=\u0026quot;group_left\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;field name='todo_ids'/\u0026gt; \u0026lt;/sheet\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Aggiorniamo il modulo\n $ docker-compose run odoo upgrade todo_plus  e ricarichiamo la pagina\nQuesta volta Odoo ci renderizza il campo come una lista di oggetti Todo, entrando in modalità modifica vediamo che è possibile aggiungere righe cercandole da quelle esistenti oppure crearne di nuove tramite la Form View specifica degli oggeti TodoTask.\nRealazioni Many2many Le relazioni Many2Many sono molto simili alle One2Many, nel senso che ad un oggetto ne vengono legati molti e sono quindi spesso rappresentato con lo stesso widget delle One2Many. La grossa differenza però è a livello di database.\nOne2many: gli oggetti sono correlati da un id presente in una colonna della tabella figlia, nel nostro caso la colonna project_id della tabella dei todo Many2many: viene creata una terza tabella composta da due colonne che fanno riferimento agli id delle due entità in relazione.\nNel nostro esempio vogliammo aggiungere una relazione fra il modello TodoTag e il modello TodoTask. Per farlo apriamo prima il file del modello models/todo_task.py e aggiungiamo il campo:\ntag_ids = fields.Many2many('todo.tag', string='Tag')  Successivamente apriamo il nostro views/todo_task.xml e aggiungiamolo anche alla vista form:\n\u0026lt;!-- All'interno del campo arch aggiungiamo --\u0026gt; \u0026lt;field name='user_id' position='after'\u0026gt; \u0026lt;field name='tag_ids'/\u0026gt; \u0026lt;/field\u0026gt;  Aggiorniamo il modulo\n$ docker-compose run odoo upgrade todo_plus  e ricarichiamo la pagina\nIl campo Tag è stato aggiunto e visualizzato come una lista di oggetti.\nUna finezza Odoo ha diversi widget che possono essere utilizzati per renderizzare i campi agli utenti (e anche loro possono essere aggiunti o modificati). Nel caso specifico Odoo ha un widget per gestire i tag. Per utilizzarlo bisogna modificare la dichiarazione nella vista form aggiungendo widget=\u0026ldquo;many2many_tags\u0026rdquo; tra gli attributi del campo tag_ids, come segue\n\u0026lt;field name='user_id' position='after'\u0026gt; \u0026lt;field name='tag_ids' widget=\u0026quot;many2many_tags\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt;  Aggiornando la pagina otteniamo una visualizzazione del campo molto più comoda ed inerente allo stesso\nContinua Ora che abbiamo creato le nostre prima relazioni possiamo occuparci di un altro strumento molto utile che Odoo ci fornisce sui modelli, i computed fields\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/estendere_viste/",
	"title": "Estendere le Viste",
	"tags": [],
	"description": "",
	"content": " Un po\u0026rsquo; di teoria Le viste Form, List e Search sono definite utilizzando la struttura XML arch. Per estenderle dobbiamo modificare quelle definizioni XML e farlo significa localizzare i tag XML che vogliamo cambiare e introdurre le nostre modifiche in quei punti.\nCominciamo subito con un esempio di una vista che ne estende un\u0026rsquo;altra:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_form_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_task_form_view\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Si nota che l\u0026rsquo;unica differenza dalla dichiarazione di una vista normale è la presenza del compo inherit_id in cui si definisce l\u0026rsquo;identificativo della vista che si vuole estendere.\nIl metodo standard per indicare gli elementi XML da modificare è utilizzare un espressione XPath per identificare un elemento presente nella vista. Una volta identificato si può decidere che tipo di modifica apportare.\nPer fare un esempio, se nel nostro form del modello TodoTask volessimo aggiungere il campo deadline_date prima del campo is_done aggiungeremmo questa righa al nostro campo arch\n\u0026lt;!-- Localizza il campo is_done con xpath e specifica la posizione--\u0026gt; \u0026lt;xpath expr=\u0026quot;//field[@name]='is_done'\u0026quot; position=\u0026quot;before\u0026quot;\u0026gt; \u0026lt;!-- Aggiunge il campo deadline_date in quel determinato punto --\u0026gt; \u0026lt;field name=\u0026quot;deadline_date\u0026quot;/\u0026gt; \u0026lt;/xpath\u0026gt;  XPath è uno strumento molto potente ed espressivo, ma spesso troppo prolisso. In questo esempio, come nella maggior parte dei casi, il nostro intento è quello di localizzare uno specifico tag field all\u0026rsquo;interno della vista, quindi le nostre espressioni xpath saranno spesso molto simili. Per semplificare il lavoro, Odoo fornisce una scorciatoia per questo tipo di espressione:\n\u0026lt;field name=\u0026quot;is_done\u0026quot; position=\u0026quot;before\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;deadline_date\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt;  Utilizzando xpath possiamo in compenso localizzare quasiasi altro tag all\u0026rsquo;interno della vista come \u0026lt;sheet\u0026gt;, \u0026lt;form\u0026gt;, \u0026lt;group\u0026gt; ma anche i classsici \u0026lt;div\u0026gt;.\nL\u0026rsquo;attributo position può assumere diversi valori:\n after aggiunge all\u0026rsquo;elemnto padre, dopo il nodo indicato beforer aggiunge all\u0026rsquo;elemnto padre, prima il nodo indicato inside aggiunge all\u0026rsquo;interno del nodo indicato (default) replace sostituisce l\u0026rsquo;elemento indicato attributo modifica gli attributi XML dell\u0026rsquo;elemento indicato  Estendere le nostre viste Prima di procedere dobbiamo aggiungere al nostro modulo il file XML che conterrè le definizione delle nostre viste ereditate. Come per il precedente modulo aggiungiamo la cartella views/ e al suo interno creiamo il file todo_task.xml\n todo_user/ models/ __init__.py todo_task.py views/ todo_task.xml __init__.py __manifest__.py  Successivamente dobbiamo dichiarare il nuovo file aggiunto nel manifesto dell\u0026rsquo;applicazione\n{ 'name': 'Multiuser TODO', 'description': 'Estende la Todo app per farla diventare Multi Utente', 'author': 'Metadonors', 'depends': ['todo_app'], # Aggiungiamo questa sezione 'data': [ 'views/todo_task.xml' ] }  Inizializziamo il nostro file todo_task.xml con questo contenuto:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;/odoo\u0026gt;  Estendere la Form View Per mettere insieme quello che abbiamo detto fin\u0026rsquo;ora possiamo procedere a modificare la nostra Form View aggiungendo i campi nuovi e andando a nascondere il campo active. Aggiungiamo quindi la nostra vista ereditata dentro il tag \u0026lt;odoo\u0026gt; del file todo_task.xml:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_form_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_app.todo_task_form_view\u0026quot;/\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;!-- Dopo il campo 'name' aggiungi il campo 'user_id' --\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;!-- prima del campo 'is_done' aggiungi il campo 'deadline_date' --\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot; position=\u0026quot;before\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;deadline_date\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;!-- modifica gli attributi del campo 'active' per rederlo invisibile --\u0026gt; \u0026lt;field name=\u0026quot;active\u0026quot; positiion=\u0026quot;attributes\u0026quot;\u0026gt; \u0026lt;attribute name=\u0026quot;invisible\u0026quot;\u0026gt;1\u0026lt;/attribute\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Una volta effettuata la modifica possiamo aggiornare il nostro modulo con\n $ docker-compose run odoo upgrade todo_user  ricaricare la pagine nel nostro browser e ottenere questo form\nEstendere la List View Nello stesso modo procediamo a modificare la List View andando ad aggiungere il campo dell\u0026rsquo;incaricato subito dopo il nome del task. Per farlo aggiungiamo un altro record al nostro file todo_task.xml\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_tree_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.tree\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_app.todo_task_tree_view\u0026quot;/\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;!-- Dopo il campo 'name' aggiungi il campo 'user_id' --\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  aggiorniamo il nostro modulo con\n $ docker-compose run odoo upgrade todo_user  ricaricare la pagine nel nostro browser e visualizziamo la lista\nEstendere la Search View Per finire aggiungiamo la possibilita di ricercare per utente nella nostra Search View\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_search_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.search\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_app.todo_task_search_view\u0026quot;/\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;!-- Aggiungi il campo 'user_id' all ricerca libera--\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot;/\u0026gt; \u0026lt;!-- Aggiungi il filtro predefinito \u0026quot;I miei task\u0026quot; --\u0026gt; \u0026lt;filter name=\u0026quot;filter_my_tasks\u0026quot; string=\u0026quot;I miei Tasks\u0026quot; domain=\u0026quot;[('user_id','=',uid)]\u0026quot; /\u0026gt; \u0026lt;!-- Aggiungi il filtro predefinito \u0026quot;Task non assegnati\u0026quot; --\u0026gt; \u0026lt;filter name=\u0026quot;filter_not_assigned\u0026quot; string=\u0026quot;Non assegnati\u0026quot; domain=\u0026quot;[('user_id','=', False)]\u0026quot; /\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  aggiorniamo il nostro modulo con\n $ docker-compose run odoo upgrade todo_user  ricaricare la pagine nel nostro browser e controlliamo come e\u0026rsquo; cambiato il form di ricerca\nContinua Ora possiamo continuare andando a vedere come modificare i dati dei moduli\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/prime_viste/",
	"title": "Le viste",
	"tags": [],
	"description": "",
	"content": " Le viste descrivono l\u0026rsquo;interfaccia utente. Ogni vista è strutturata in un file XML, che è utilizzato dal client web per generare le pagine HTML in grado di gestire i dati generati dal nostro backend.\nNelle viste abbiamo dei menu item che ci permettono di attivare funzionalità o navigazione scatenando delle actions. Per esempio, il menu item Users processa una action chiamata anchessa Users, che renderizza le viste per la gestione degli utenti.\nPer ogni modello sono disponibili diversi tipi di viste, le principali che utilizzeremo sono: list view, form view e search view.\nCreazione del MenuItem e della ActWindow Generalemente le viste sono raggruppate nella cartella views all\u0026rsquo;interno del modulo. Prima della creazione della vista vera e propria, abbiamo bisogno di un menu item che ci permetta di navigare alla nostra applicazione Todo Task. Per farlo creiamo la cartella views e al suo interno il file todo_menu.xml ottenendo la seguente struttura\ntodo_app/ models/ __init__.py todo_model.py views/ todo_menu.xml __init__.py __manifest__.py  e aggiungiamo il seguente contenuto che definisce l\u0026rsquo;oggetto menu e l\u0026rsquo;azione necessaria per navigare verso l\u0026rsquo;applicazione:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;!-- Azione che apre la vista list Todo Task --\u0026gt; \u0026lt;act_window id=\u0026quot;action_todo_task\u0026quot; name=\u0026quot;ToDo Task\u0026quot; res_model=\u0026quot;todo.task\u0026quot; view_mode=\u0026quot;tree,form\u0026quot; /\u0026gt; \u0026lt;!-- Oggetto menu che apre la lista dei Todo --\u0026gt; \u0026lt;menuitem id=\u0026quot;menu_todo_task\u0026quot; name=\u0026quot;Todos\u0026quot; action=\u0026quot;action_todo_task\u0026quot; /\u0026gt; \u0026lt;/odoo\u0026gt;  Questo piccolo pezzo di codice è un file Odoo data. Odoo lo legge e aggiunge nel suo database queste definizioni. Nello specifico abbiamo definito:\n un elemento \u0026lt;act_window\u0026gt; che definice un\u0026rsquo;azione client side che apre le viste relative al modello di nome todo.task con le viste tree e form abilitate\n un elemento \u0026lt;menuitem\u0026gt; che definisce un menu primario che una volta cliccato scatena l\u0026rsquo;azione con id _action_todotask\n  Entrambi questi elementi hanno un attributo id, spesso chiamato XML ID, che è molto importante: è utilizzato nel modulo e all\u0026rsquo;esterno del modulo per fare riferimento a quell\u0026rsquo;oggetto specifico. Quindi, per esempio, per invocarlo, modificarlo o eliminarlo. Nel caso specifico il \u0026lt;menuitem\u0026gt; utilizza l\u0026rsquo;id della \u0026lt;act_window\u0026gt; per invocarla.\nCon viste Tree in Odoo si intendo i listati. Vengono chiamati tree per ragioni storiche anche se attualmente non hanno più un comportamento da struttura ad albero se non in rari casi, come i raggruppamenti, dove permettono di visualizzare i dati su due livelli.\n Come per i modelli, Odoo attualmente non sa dell\u0026rsquo;esistenza del file che abbiamo appena creato. Per dichiararlo dobbiamo aggiungere al file __manifest__.py l\u0026rsquo;attributo data che elenca tutte le risorse (codice Python escluso) disponibili in questo modulo.\nQuindi aprimo il file __manifest__.py e modifichiamolo di conseguenza:\n{ 'name': 'Applicazione TODO', 'description': 'Gestisci i tuoi TODO', 'author': 'Fabrizio Arzeni', 'depends': ['base'], 'application': True, # Aggiungiamo questa parte 'data': [ 'views/todo_menu.xml' ] }  Ogni definizione che aggiungiamo in file XML viene letta e aggiunta nel database da Odoo in fase di upgrade del modulo. Quando aggiungiamo oggetti dobbiamo effettuare un upgrade manuale del modulo per renderli disponibili. In modalita sviluppo del backend (\u0026ndash;dev=all) le modifiche invece vengono lette automaticamente ed è sufficiente ricaricare la pagina. In produzione invece è sempre necessario effettuare l\u0026rsquo;upgrade del modulo.\n A questo punto non ci resta che effettuare l\u0026rsquo;upgrade del modulo e ricaricare la nostra pagina.\n$ docker-compose run odoo upgrade todo_app  Se abbiamo fatto tutto correttamente, dovremmo vedere:\nCreazione delle vista Form Premendo il tasto Create, Odoo ci presenta un Form di default basato sulla definizione dei campi che gli abbiamo dato. Il form presentato è molto basilare, presenta semplicemente i campi definiti, nelle applicazioni reali andremo a creare un form specializzato per ogni tipo di modello.\nLe viste Form in odoo hanno un duplice utlizzo: modifica e visualizzazione dei dati. Quindi definendo una vista Form stiamo nello stesso momento creando due schermate: quella utilizzata per visualizzare i dati di un record e quella per modificarli. Rimane comunque possibile modificare questo comportamento specificando viste distinte per la visualizzazione e la modifica.\n Per farlo dobbiamo aggiungere, dichiarandolo in un file XML Odoo data, un oggetto di tipo ir.ui.view. Quindi creiamo un nuovo file XML all\u0026rsquo;interno della cartella view di nome todo_views.xml e otteniamo:\ntodo_app/ models/ __init__.py todo_model.py todo_views.py views/ todo_menu.xml todo_views.xml __init__.py __manifest__.py  All\u0026rsquo;interno di questo file aggiungiamo il seguente contenuto:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_form_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;form string=\u0026quot;ToDo Task Form\u0026quot;\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;active\u0026quot; readonly=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt;  Questo codice aggiungne una vista con l\u0026rsquo;idendificativo _todo_task_formview. L\u0026rsquo;attributo model indica a Odoo che deve usare questa vista sugli oggetti di tipo todo.task. L\u0026rsquo;attributo arch indica il contenuto effetivo della vista e il tag form specifica che la vista definita è di tipo Form View.\nCome per il menu, dobbiamo aggiungere questo file al manifesto del modulo per far si che Odoo lo riconosca e lo carichi. Apri quindi il __manifest__.py modficalo come segue:\n{ 'name': 'Applicazione TODO', 'description': 'Gestisci i tuoi TODO', 'author': 'Fabrizio Arzeni', 'depends': ['base'], 'application': True, 'data': [ 'views/todo_menu.xml', 'views/todo_views.xml', # Aggiungiamo questa riga ] }  Una volta fatto possimo effettuare l\u0026rsquo;upgrade del modulo e aggiornare la pagina.\n$ docker-compose run odoo upgrade todo_app  Se tutto è andato bene otterremo una pagina di questo genere:\nChe ci permetti di effettuare le basiche operazioni CRUD sui nostri modelli. Ma vediamo come possiamo migliorare ancora un po\u0026rsquo; la visualizzazione dei dati.\nSebbene ci sia libertà nella strutturazione delle pagine in Odoo, ci sono alcune linee guida che è utile sapere (e seguire) per rendere più semplice la vita agli utenti.\nLa struttura delle Form View di Odoo è piuttosto standard e prende ispirazione dai fogli di carta. La pagina è suddivisa in due parti: - un tag \u0026lt;header\u0026gt; che fa riferimento alla barra orizzontale in alto, dove solitamente si posizionano i bottoni di azione e gli stati dell\u0026rsquo;oggetto - un tag \u0026lt;sheet\u0026gt; che rappresenta la parte centrale della pagina (il foglio di carta), dove vengono rappresentati i dati.\nUn altro elemento utile nei from è il tag \u0026lt;group\u0026gt; che permette di ragguppare i campi, suddividendoli su più colonne.\nPer creare queste due aree e aggiungere un paio di bottoni modifichiamo il nostro file todo_views.xml, aggiungendo queste due aree:\n\u0026lt;form string=\u0026quot;ToDo Task Form\u0026quot;\u0026gt; \u0026lt;!-- Aggiungiamo l'header, dove posizioneremo i bottoni--\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- Aggiungiamo un pulsante per modificare lo stato Fatto del task --\u0026gt; \u0026lt;button name=\u0026quot;do_toggle_button\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Toggle Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt; \u0026lt;!-- Aggiungiamo un pulsante per rimuovere i task in stato fatto --\u0026gt; \u0026lt;button name=\u0026quot;do_clear_done\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Clear All Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- Aggiungiamo lo sheet per incapsulare il contenuto --\u0026gt; \u0026lt;sheet\u0026gt; \u0026lt;!-- Raggruppiamo i campi su due colonne e assegnamo un identificativo ai vari gruppi --\u0026gt; \u0026lt;group name=\u0026quot;group_top\u0026quot;\u0026gt; \u0026lt;group name=\u0026quot;group_left\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;group name=\u0026quot;group_right\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;active\u0026quot; readonly=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/sheet\u0026gt; \u0026lt;/form\u0026gt;  In questo caso, non avendo aggiunto record nel data file sarà sufficiente ricaricare la pagina per vedere le modifiche\n Ricaricando la pagina vediamo che è stata aggiunta una barra in alto contenente i due bottoni e che il form è stato racchiuso in un box.\nCreazione delle vista List Anche le viste Tree (i listati) possono - e devono - essere personalizzate in base al modello, per farlo si va a definire un altro record nel file delle viste del modello come nel cado delle Form View, ma questa volta utilizzando il tag \u0026lt;tree\u0026gt;.\nAprimo quindi il file todo_views.xml e aggiungiamo:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_tree_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.tree\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;tree decoration-muted=\u0026quot;is_done==True\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot;/\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Con questo codice creeremo un listato con due colonne. Abbiamo anche utilizzato una finezza, nel tag tree utlizziamo l\u0026rsquo;attributo decoration-{$name} della vista. Per maggiori informazioni leggi la documentazione ufficiale di Odoo a riguardo.\nSe tutto è andato bene dovremo ottenere questa schermata:\nCreazione delle vista Search Le Search View sono leggermente differenti da quelle che abbiamo visto finora. La grossa differenza è che in questo caso non abbiamo una schermata dedicata alla ricerca, ma con la definizione di una Search View andiamo a modificare il blocco di ricerca presente in alto a destra nelle Tree View.\nPer farlo aggiungiamo un altro record al file todo_views.xml come di seguito:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_search_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.search\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;search\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;filter string=\u0026quot;Not Done\u0026quot; domain=\u0026quot;[('is_done','=',False)]\u0026quot;/\u0026gt; \u0026lt;filter string=\u0026quot;Done\u0026quot; domain=\u0026quot;[('is_done','!=',False)]\u0026quot;/\u0026gt; \u0026lt;/search\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Il tag \u0026lt;field\u0026gt; definisce i campi su cui è possibile effettuare la ricerca digitando nel box testuale. I tag \u0026lt;filter\u0026gt; aggiungono invece dei filtri predefiniti nel menu dei filtri. Vedremo successivamente qual\u0026rsquo;è il dignificato dell\u0026rsquo;attributo domain.\nContinua A questo punto siamo in grado di creare, visualizzare, cancellare, listare, cercare e filtrare i dati relativi al nostro nuovo modello, non ci rimane che aggiungere della logica applicativa che ci permetta di effettuare operazioni più strutturate.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/basics/concetti/",
	"title": "Concetti Base",
	"tags": [],
	"description": "",
	"content": " Prima di cominciare è necessario affrontare un po\u0026rsquo; di teoria che sta alla base del framework Odoo. Odoo è un framework applicativo modulare, i suoi principali componenti sono i moduli e le applicazioni.\nModuli I moduli sono i componenti essenziali che possono essere aggiunti a Odoo. Ogni modulo può implementare nuove funzionalità oppure modificare quelle esistenti. Ogni modulo è costituito da una cartella contenente un file __manifest.py__ più altri file che implementano le sue funzionalità.\nApplicazioni Le applicazioni sono moduli di ordine maggiore, che implementano funzionalità a più alto livello o sempliccemente più complesse. Sono gli elementi essenziali dell\u0026rsquo;aspetto funzionale, come per esempio l\u0026rsquo;applicazione CRM o Contabilità e sono a loro volta basate sulle funzionalità di tanti moduli.\nSe state implementando un modulo complesso che aggiunge funzionalità specifiche a Odoo è probabile che sia un applicazione. Se state aggiungendo o modificando alcuni semplici aspetti invece è probabile che stiate sscrivendo un modulo.\nTecnicamente non c\u0026rsquo;è nessuna differenza fra i due, semplicemente le applicazioni vengono mostrate nell\u0026rsquo;elenco delle App disponibili all\u0026rsquo;utente.\nAdattare il sistema Generalmmente per adattare Odoo alle diverse esigenze non si modifica mai il codice esistente. Piuttosto si creano nuovi moduli che vanno a innestarsi sugli esistenti per modificare le funzionailtà.\nIn questo corso creeremo un applicazione con pochissime dipendenze, per questioni pratiche, ma nei casi reali è molto più probabile andare a lavorare sui moduli core di odoo oppure su moduli terzi resi disponibili da altri sviluppatori.\nInstalliamo il nostro primo modulo Per fare un esempio, procediamo all\u0026rsquo;installazione di un modulo fornito dalla comunità. Installeremo un modulo che estende la ui del nostro backend rendendola più simile alla versione di Odoo Enterprise.\nIl modulo è già stato pacchettizzato e inserito nel codice, possiamo quindi procedere con l\u0026rsquo;installazione da interfaccia web.\nAndiamo su http://localhost mettiamo username e password e accediamo alla lista delle app.\nDeselezioniamo il filtro \u0026ldquo;Apps\u0026rdquo; dalla barra di ricerca e inseriamo la stringa \u0026ldquo;Material\u0026rdquo;\nClicchiamo su Install e\u0026hellip;fatto. Abbiamo installato il nostro primo modulo e subito il nostro Odoo ha un look più moderno.\nContinua Ora possiamo andare a creare la nostra prima applicazione\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/",
	"title": "Estendere i moduli",
	"tags": [],
	"description": "",
	"content": " Capitolo 3 ESTENDERE L\u0026rsquo;ESISTENTE La vera potenza di Odoo si esprime nel riutilizzo delle applicazioni e dei moduli esistenti e nell\u0026rsquo;adattarli alle esigenze specifiche del momento. Vediamo ora come è strutturato il meccanismo di eredità che il framework ci offre.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/views/list_view/",
	"title": "List e Search View",
	"tags": [],
	"description": "",
	"content": " Le Liste Come abbiamo vito le liste vengono rappresentate dal tipo tree\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_tree_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.tree\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;tree decoration-muted=\u0026quot;is_done==True\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot;/\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  L\u0026rsquo;attributo decoration-NAME permette di passare un\u0026rsquo;espressione Python che, se vera, modifica l\u0026rsquo;aspetto della riga considerata. NAME puo\u0026rsquo; essere valorizzato come bf o it per renderizzare la riga in grassetto o corsivo, oppure può avere una classe Bootstrap per il colore del test muted, info, danger o primary.\nAltri attributi utli sull\u0026rsquo;elemento tree:\n default_order permette di sovrascrivere il metodo di ordinamento di default dei dati visualizzati create, delete e edit se passati con il valore \u0026ldquo;false\u0026rdquo; disabilitano l\u0026rsquo;azione corrispondente nella vista editable rende le righe modificabili direttamente nella lista, i valori possibili sono top o bottom e indica dove verranno aggiunti i nuovi elementi  Le ricerche Nelle ricerche possiamo scegliere su quali campi effettuare la ricerca di default quando digitiamo nell\u0026rsquo;input in alto a sinistra, possiamo definire dei filtri predefiniti attivabili con un click e possiamo anche fornire delle regole di raggruppamento predefinite\nEcco un esempio\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_search_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.search\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;search\u0026gt; \u0026lt;!-- campi su cui effettuare una ricerca libera --\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot;/\u0026gt; \u0026lt;!-- filtri predefiniti --\u0026gt; \u0026lt;filter string=\u0026quot;Not Done\u0026quot; domain=\u0026quot;[('is_done','=',False)]\u0026quot;/\u0026gt; \u0026lt;filter string=\u0026quot;Done\u0026quot; domain=\u0026quot;[('is_done','!=',False)]\u0026quot;/\u0026gt; \u0026lt;separator/\u0026gt; \u0026lt;!-- raggruppamento predefinito --\u0026gt; \u0026lt;filter string=\u0026quot;By User\u0026quot; name='group_user' context=\u0026quot;{'group_by': 'user_id'}\u0026quot;/\u0026gt; \u0026lt;/search\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Abbiamo qui definito due campi su cui effettuare la ricerca libera name e user_id. Quando l\u0026rsquo;utente comincerà a digitare nel campo di ricerca verrà fuori un menu a tendina che chiederà all\u0026rsquo;utente su quale campo effettuare la ricerca.\nPoi abbiamo definito due filtri predefiniti che filtrano sul valore dell\u0026rsquo;attributo is_done, questi filtri sono attivabili indipendentemente uno dell\u0026rsquo;altro e se attivi entrambi vengono applicati in OR. Se invece fossero divisi da un \u0026lt;separator\u0026gt; sarebbero applicati in AND\nIl terzo tag fitler invece setta un raggruppamente modificanto il context della vista.\nSearch Field I tag field delle Search View accettano questi parametri:\n name il nome del campo su cui cercare string la label da visualizzare all\u0026rsquo;utente operator l\u0026rsquo;operatore di confronto utilizzato per la ricerca, di default è = per i numeri e ilike per gli altri tipi filter_domain in alternativa all\u0026rsquo;opzione operator permette di esprimere più operatori di confronto groups permette la ricerca su un determinato campo solo a un certo insieme di gruppi di utenti  Search Filter Per i tag filter invece sono dispoonibili queste opzioni:\n name il nome del filtro, non è obbligatorio ma utile perchè può essere utilizzato per modificare il filtro nelle viste figlie oppure per preselezionarlo tramite il context della vista string la labbel da presentare all\u0026rsquo;utente domain l\u0026rsquo;espressionde di dominio utilizzata quando il filtro viene selezionato context un dizionario che modifica il context della vista, solitamenet utilizzato per passare il valore di group_by groups permette l\u0026rsquo;utilizzo solo a un determinato campo solo a un certo insieme di gruppi di utenti  "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/computed_fields/",
	"title": "Computed Fields",
	"tags": [],
	"description": "",
	"content": " Tutti i campi che abbiamo definito fin qui sono gestiti manualmente. L\u0026rsquo;utente entra in modalità modifica di un oggetto, aggiorna i valori e preme salva. Oddo permette però di avere altri campi il cui valore non viene definito direttamente dall\u0026rsquo;utente ma viene invece calcola attraverso una funzione.\nComputed fields Un computed field viene dichiarato esattamente come i campi normali con l\u0026rsquo;unica differenza di avere un parametro compute che indica la funzione che Odoo utilizzerà per calcolarne il valore.\nImmaginiamo per esempio di voler mantenere nei TodoTask l\u0026rsquo;informazione relativa allora stato del progetto a cui appartengono. Gestire questo dato a mano sarebbe piuttosto oneroso, un computed field invece risolve il problema egregiamente.\nPer aggiunger questo campo al nostro modello dei progetti apriamo il file models/todo_project.py e aggiungiamo nel corpo della classe:\nproject_state = fields.Char(string='Stato progetto', compute='_compute_project_state') @api.depends('project_id') def _compute_project_state(self): for todo in self: todo.project_state = todo.project_id.state  Il decoratore @api.depends indica a Odoo di calcolore il valore del campo solo dopo aver modificato il valore dei campi espressi nel decoratore. Quindi in questo caso verrà ricalcolato il contatore solo quando modificheremo il valore del campo project_id.\nNel file delle viste dei progetti views/todo_tak.xml modifichiamo la Form View per visualizzare questo valore. Aggiungiamo nel campo arch:\n\u0026lt;field name='name' position='after'\u0026gt; \u0026lt;field name='project_id'/\u0026gt; \u0026lt;field name='project_state'/\u0026gt; \u0026lt;/field\u0026gt;  Aggiorniamo il modulo\n $ docker-compose run odoo upgrade todo_plus  e ricarichiamo la pagina\nOra è presente il lo stato del progetto, se proviamo a chiudere il progetto vedremo che la stessa informazione si aggiornera anche su tutti i suoi Todo.\nFiltrare i Computed Fields I computed field non possono essere usati come filtro sull\u0026rsquo;oggetto in cui vengono definiti a meno di non implementare esplicitamente una funzione di ricerca. Quindi a fianco al parametro compute, dobbiamo passargli anche un argomento search specificado il nome della funzione che vogliamo utilizzare.\nNella nostra class TodoTask modifichiamo l\u0026rsquo;attributo project_state\nproject_state = fields.Char(string='Stato progetto', compute='_compute_project_state', search='_search_project_state',)  e tra i metodi aggiungiamo:\ndef _search_project_state(self, operator, value): return [('project_id', operator, value)]  Scrivere i Computed Fields È anche possibile specificare una funzione che permetta di scrivere i computed fields. Questa funzione si prende carico di normalizzare l\u0026rsquo;input per forlo arrivare al database nel modo corretto. Al pari di compute e search, la funzione si specifica tra i parametri del campo con il nome di inverse:\nModifichiamo il campo aggiungendo il parametro inverse:\nproject_state = fields.Char(string='Stato progetto', compute='_compute_project_state', search='_search_project_state', inverse='_wrtie_project_state')  e tra i metodi aggiungiamo:\ndef _wrtie_project_state(self): self.project_id.state = self.project_state  Salvare i Computed Fields Un\u0026rsquo;altra possibilità è quella di comunicare ad Odoo di salvare il valore del computed field in database. Dal momento che i valori vengono salvati a database non sarà più necessario specificare le funzioni search e inverse perchè Odoo sarà già in grado di gestirle in autonomia. Per salvare un computed field in database è sufficiente specificare store=True tra i parametri del campo.\nRelated Fields Il computed field che abbiamo implementato è un classico: si occupa semplicemente di copiare il valore di un campo di un oggetto correlato al nostro. Questo tipo di comportamento può essere gestito in completa autonomia da Odoo, senza dover per forza esplicitare tutte le funzioni necessarie.\nI related fields si dichiarano nello stesso modo dei computed field ma specificanto l\u0026rsquo;argomento related anzichè compute. Il valore dell\u0026rsquo;argomento related sarà una stringa in dotted-notation che identifica il campo che si vuole relazionare.\nNel nostro caso sarebbe:\nproject_state = fields.Char(string='Stato progetto', related='project_id.state')  Continua Per terminare la nostra panoramica sui modelli, vediamo ora come possiamo esprimere dei vincoli d\u0026rsquo;integrità per i nostri dati.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/estendere_dati/",
	"title": "Estendere i Dati",
	"tags": [],
	"description": "",
	"content": " A differenza delle viste i file xml contenenti dati, come i menuitem oppure le security rules, non hanno l\u0026rsquo;elemento arch e non possono quindi essere modificati utilizzanto XPath. Ma possono comunque essere modificati, rimpiazzando i valori contenuti nei loro campi.\nOgni volta che dichiariamo un \u0026lt;record id=\u0026ldquo;x\u0026rdquo; model=\u0026ldquo;y\u0026rdquo;\u0026gt; Odoo effettua una insert o una update nel database, quindi riutilizzando gli stessi id possiamo andare ad aggiornare i dati inseriti dai moduli genitori.\nVediamo nel dettaglio cosa significa.\nModificare i Menuitem e le Action Per fare un esempio modifichiamo l\u0026rsquo;elemento del menu creato dalla todo_app andando a modificare la sua stringa in I miei Todo. Per farlo possiamo aggiungere in fondo al file views/todo_task.xml\n\u0026lt;!-- Modifica l'elemento del menu --\u0026gt; \u0026lt;record id=\u0026quot;todo_app.menu_todo_task\u0026quot; model=\u0026quot;ir.ui.menu\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;I miei Todo\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Possiamo anche modificare la action che abbiamo creato precedentemente. Le action possono avere un parametro context opzionale che va a modificare il comportamento della stessa, per esempio aggiungendogli dei valori di default che verranno utilizzati per popolare field o filters. Quello che faremo sarà modificare la action per far si che venga visualizzata la pagina della lista Todo con il filtro I miei Task preselezionato. Aggiungiamo quindi in fondo al file views/todo_task.xml\n\u0026lt;!-- Modifica la action --\u0026gt; \u0026lt;record id=\u0026quot;todo_app.action_todo_task\u0026quot; model=\u0026quot;ir.actions.act_window\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;context\u0026quot;\u0026gt;{'search_default_filter_my_tasks': True}\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Se abbiamo fatto tutto correttamente dopo un upgrade del modulo\n $ docker-compose run odoo upgrade todo_user  dovremmo vedere:\nModficare le regole di sicurezza La nostra applicazione precedente permette agli utenti di vedere solo i Task creati da loro stessi. Ora vogliamo che i task siano accessibili all\u0026rsquo;incaricato e a tutti i follower del task. Come per i menuitem e le actions andremo a sovrascriere la regola precedentemente creata modificando il suo campo domain_force.\nEssendo una regola di sicurezza, per convenzione, la metteremo nella sottocartella security/ in un file che chiameremo todo_access_rules.xml\n todo_user/ models/ __init__.py todo_task.py views/ todo_task.xml security/ todo_access_rules.xml __init__.py __manifest__.py  che andremo successivamente ad aggiungere anche al manifesto dell\u0026rsquo;applicazione:\n{ 'name': 'Multiuser TODO', 'description': 'Estende la Todo app per farla diventare Multi Utente', 'author': 'Metadonors', 'depends': ['todo_app'], 'data': [ 'security/todo_access_rules.xml', # \u0026lt;-- Aggiungiamo questa riga 'views/todo_task.xml' ] }  Il contenuto del file per la regola di accesso sarà quindi il seguente:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;data noupdate=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;record model=\u0026quot;ir.rule\u0026quot; id=\u0026quot;todo_app.todo_task_user_rule\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.user.rule\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model_id\u0026quot; ref=\u0026quot;model_todo_task\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;groups\u0026quot; eval=\u0026quot;[4, ref('base.group_user')]\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;domain_force\u0026quot;\u0026gt; ['|', ('user_id', 'in', (user.id, False)), ('message_follower_ids', 'in', [user.partner_id.id])] \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt;  Continua Abbiamo parlato di Follower, perchè mettevamo le basi per la prossima funzionalità: aggiungere un pizzico di social networking dando agli utenti la possibilità di commentare e seguire l\u0026rsquo;evoluzione dei nostri task. Questa è una funzionalità già presente in Odoo implementarla ci permette di vedere come riutilizzare il codice di terzi moduli\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/prima_funzione/",
	"title": "La logica",
	"tags": [],
	"description": "",
	"content": " A questo punto è arrivato il momento di aggiungere della logica applicativa al nostro modulo. Per farlo possiamo sfruttare i bottoni che abbiamo aggiunto nella sezione precedente relativa alle viste.\nAggiungere la logica applicativa Nella precedente sezione abbiamo aggiunto due bottoni per invocare delle funzioni Python sul nostro backend. Riporto qui il codice interessato per comodità.\n\u0026lt;button name=\u0026quot;do_toggle_button\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Toggle Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt;  In questo tag stiamo definendo alcuni attributi, vediamoli nel dettaglio:\n string è la stringa che verrà visualizzata all\u0026rsquo;utente all\u0026rsquo;interno del bottone class è la classe CSS che verrà applicata al bottone (in questo caso ne applichiamo una predefinita in Odoo) type è il tipo di azione che deve essere scatenata quando il bottone viene premuto, può essere valorizzato come  object per invocare un metodo del modello action per invocare un\u0026rsquo;azione generica (come quella che abbiamo utilizzato per accedere all\u0026rsquo;applicazione)  name nel caso in cui type=object name rappresenta il nome del metodo che verrà invocato, in questo caso do_toggle_button  Per altre informazioni fai riferimento alla documentazione ufficiale di Odoo\nQuindi avendo definito un bottone con type=object e name=do_toggle_button non ci rimane che aggiungere questo metodo alla classe Python che rappresenta il modello. Apriamo quindi il file models/todo_model.py e aggiungiamo un metodo alla classe:\n# Nell'intestazione modifichiamo l'import aggiungendo api from odoo import models, fields, api  # Nel corpo della classe aggiungiamo il metodo @api.multi def do_toggle_button(self): for todo in self: todo.is_done = not todo.is_done  Poche righe, ma tanti concetti.\nPrima di tutto il decoratore @api.multi. Odoo è un software scritto con una logica API first, che significa che il codice che scrivete nel backend (in Python) è completamente slegato da quello che avviene nel frontend (che invece è scritto in Javascript). Ogni funzione che volete esporre al frontend deve essere esposta come un API JSONRPC (un protocollo RPC di qui potete trovare maggiori infomazioni su internet).\nIl decoratore @api.multi dice ad Odoo che volete esporre il metodo al frontene (@api) e che quel metodo puo essere eseguito su uno o più record alla volta (multi). Quindi potete invocare questo metodo su un solo record todo in una chiamata come su 100 o 1000.\nEssendo un metodo multi il self dell\u0026rsquo;oggetto rappresenta non un istanza sola, ma un RecordSet che è una struttura di odoo che raggruppa oggetti dello stesso tipo e ha il principale scopo di eseguire operazioni in batch ottimizzate su molti oggetti. Quindi ciclando sul self stiamo andando a lavorare su ogni record presente in questa chiamata.\nPer l\u0026rsquo;altro bottone invece:\n\u0026lt;button name=\u0026quot;do_clear_done\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Clear All Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt;  Vediamo che abbiamo dichiarato che vogliamo invocare il metodo do_clear_done che andiamo a implementare nel nostro models/todo_models.py come segue\n@api.multi def do_clear_done(self): dones = self.search([ ('is_done', '=', True) ]) dones.write({ 'active': False })  Con il metodo search andriamo a cercare i todo che ci interessano passandogli un domain per la ricerca e infine aggiorniamo il loro stato come inattivo.\nI domain sono il principale metodo per effettuare ricerche nel database usando il framework di Odoo. Li vediamo pi\\ nel dettaglio successivamente.\nContinua Con quest\u0026rsquo;ultimo passaggio abbiamo terminato la nostra panoramica delle funzionalità base di un modulo Odoo. Rimane una piccola macchia che ci permette però di andare a guardare un ultimo aspetto riguardante i nostri modelli.\nSe ci fate caso, avviando il server di odoo, viene visualizzato un WARNING di questo tipo:\nWARNING demo odoo.modules.loading: The model todo.task has no access rules, consider adding one. E.g. access_todo_task,access_todo_task,model_todo_task,,1,0,0,0  La ragione di questo avviso è legata al meccanismo delle regole di accesso ai dati di Odoo, vediamo come funzionano e come risolvere nella prossima sezione.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/",
	"title": "I Modelli",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Modelli Odoo è un framework MVC, i Modelli sono la M del paradigma e ci permettono di rappresentare i nostri dati in maniera strutturata, come per esempio i Prodotti, le Vendite, le Fatture o i Clienti. Vediamo che srtumenti abbiamo per strutturarli al meglio.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/views/graph_pivot_views/",
	"title": "Pivot e Graph View",
	"tags": [],
	"description": "",
	"content": " Pivot I pivot sono un potente strumento di analisi dei dati fornito da Odoo. Una vista pivot rappresenta i dati in una matrice dinamica.\nUn esempio di vista Pivot\n\u0026lt;record id='view_pivot_todo_task' model='ir.ui.view'\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.pivot\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name='arch' type='xml'\u0026gt; \u0026lt;pivot\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot; type='col'\u0026gt; \u0026lt;field name=\u0026quot;work_hours\u0026quot; type='measure'\u0026gt; \u0026lt;/pivot\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Graph Le Graph View rappresentano i dati in forma di grafici\nUn esempio\n\u0026lt;record id='view_graph_todo_task' model='ir.ui.view'\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.graph\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name='arch' type='xml'\u0026gt; \u0026lt;graph\u0026gt; \u0026lt;field name=\u0026quot;work_hours\u0026quot; type='measure'\u0026gt; \u0026lt;/graph\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/vincoli/",
	"title": "Vincoli",
	"tags": [],
	"description": "",
	"content": " Per assicurare l\u0026rsquo;integrità dei nostri dati Odoo ci fornisce due strumenti principali che possiamo applicare ai nostri modelli: Vincoli SQL e Vincoli Python.\nVincoli SQL I vincoli SQL sono aggunti direttamente alla definizione della tabella a livello di database e sono controllati quindi direttamente da PostgreSQL. Una volta configurati non sarà quindi possibile creare eccezioni per aggirarli.\nPer configurare un vincolo sql si aggiunge un attributo sql_constraints che è un alista di tuple, in ogni tupla viene espresso l\u0026rsquo;identificatore del vincolo, il codice SQL per il vincolo e il messaggio di errore da usare.\nUn classico è quello di aggiungere un vincolo di unicità a un campo, per esempio:\nclass TodoTask(models.Model): _sql_constraints = [ ('todo_task_unique_name', 'UNIQUE(name)', 'Il titolo del task deve essere unico') ]  Fa si che non sia più possibile aggiungere due task con lo stesso titolo.\nVincoli Python I vincoli Python invce possono essere utilizati per fare controlli di qualsiasi tipo utilizzando una funzione specifica. La funzione deve essere dichiarata utilizzando il decoratore @api.constraints indicando la lista di campi che dovranno passare i controlli. La validazione è chiamata ogni volta che si modfificheranno alcuni o tutti i campi dichiarati.\nPer esempio\nfrom odoo.exception import ValidationError # all'intterno della classe TodoTask @api.constraints('name') def _check_name_length(self): for todo in self: if len(todo.name) \u0026lt; 10: raise ValidationError('Il titolo del task è troppo corto')  Controlla che il titolo di ogni task sia lungo almeno 10 caratteri.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/aggiungere_funzionalita/",
	"title": "Aggiungere funzionalità",
	"tags": [],
	"description": "",
	"content": " Finora abbiamo visto come estendere applicazioni esistenti aggiungendo funzionalità create da noi. Ma Odoo permette di fare molto di più: possiamo aggiungere funzionalità implementate in moduli scritti da altre persone.\nNel nostro caso vogliamo aggiugere la possibilità per gli utenti di commentare i task e di poterli seguire, alla maniera di Twitter. Questa funzionalità in Odoo è implementata nel modulo mail, più specificatamente nel modello mail.thread di quel modulo.\nPer aggiungerlo al nostro modello todo.task dobbiamo procede in questo modo:\n Aggiungere il modulo mail alle nostre dipendenze Aggiungere la classe mail.thred a quelle che eredita il nostro modello todo.task Aggiungere i campi necessari nella nostra vista Modficare le regole di accesso per questa funzionalità (lo abbiamo già fatto nella sezione precedente)  Modificare le dipendenze Apriamo il nostro file di manfiesto e modifichiamolo come segue:\n{ 'name': 'Multiuser TODO', 'description': 'Estende la Todo app per farla diventare Multi Utente', 'author': 'Metadonors', 'depends': [ 'todo_app', 'mail' # \u0026lt;-- Aggiungiamo la dipendenza ], 'data': [ 'security/todo_access_rules.xml', # \u0026lt;-- Aggiungiamo questa riga 'views/todo_task.xml' ] }  Aggiungere la classe al modello Per aggiungere la classe al modello procediamo nella stessa maniera con cui abbiamo ereditato il modello esteso dal modello base. Andiamo ad aggiungere all\u0026rsquo;attributo _inherit il modello mail.thread\nApriamo il nostro file models/todo_task.py\nclass TodoTask(models.Model): _name = 'todo.task' _inherit = ['todo.task', 'mail.thread']  Con questa semplice modifica il nostro modello thread acquisterà tutta la logica che gli serve per far funzionare la messaggistica. C\u0026rsquo;è anche da notare che mettendo due dipendenze siamo obbligati anche a specificare quale deve essere il nome del modello principale da cui ereditiamo, per questo aggiungiamo ancche l\u0026rsquo;attributo _name.\nIl modello mail.thread è un Abstract Class, che significa che non ha una tabella sua di riferimento. Può essere ssolo utiilizzato in altri modelli e va a estendere le loro funzionalità. Quindi, nella pratica, aggiungendolo andrà a modificare direttamente la tabella originale e aggiungerà al modello i metodi necessari alle sue funzionalità. Per maggiori infomazioni consultate la documentazione ufficiale di Odoo.\n Aggiungere i campi necessari alla vista A questo punto non ci rimane che aggiungere il widget delle funzionalità mail al fondo della nostra Form View del modello. Apriamo il file views/todo_task.xml e aggiungiamo nell\u0026rsquo;attributo arch questo codice XML\n\u0026lt;sheet position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;oe_chatter\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;message_follower_ids\u0026quot; widget=\u0026quot;mail_followers\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;message_ids\u0026quot; widget=\u0026quot;mail_thread\u0026quot;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/sheet\u0026gt;  Se ci fate caso i due campi message_followers_ids e message_ids non sono stati implementati esplicitamente da noi ma vengono ereditati dalla classe mail.thread.\nA questo punto non ci resta che effettuare l\u0026rsquo;upgrade del nostro modello\n $ docker-compose run odoo upgrade todo_user  ricaricare la pagina e cominciare ad aggiungere commenti\nContinua Il nostro upgrade del modulo base è finito, a questo punto possiamo andare a guardare più nel dettaglio cosa ci offre il framework Odoo. Cominciamo ad analizzare i Modelli\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/controllo_accessi/",
	"title": "Controllo Accessi",
	"tags": [],
	"description": "",
	"content": " Nella scorsa sezione abbiamo terminato la creazione del nostro modulo base. Al termine abbiamo notato che Odoo si lamentava dicendo che non abbiamo specificato delle regole di accesso per il modello da noi creato\nWARNING demo odoo.modules.loading: The model todo.task has no access rules, consider adding one. E.g. access_todo_task,access_todo_task,model_todo_task,,1,0,0,0  In Odoo tutti i modelli devono avere delle regole di accesso specificate, in caso contrario solo l\u0026rsquo;utente admin potrà accedere ai dati relativi a quel modello.\nCi sono due tipi di controlli di accesso disponibili: access control list e row level access control\n access control list sono le regole principale e obbligatorie da definire per modello, indicano l\u0026rsquo;accesso generico in termini booleani SI/NO che i gruppi di utenti hanno rispetto ai dati del modello declinati in lettura, scrittura, creazione e cancellazione row level access control sono le regole che a seguito delle access control list vengono applicate in termini di riga. Per esempio: tutti i dipendenti possono creare oggetti Todo ma possono visualizzare e utilizzare sono quelli creati da loro.  Access Control List Per farci un\u0026rsquo;idea di come sono strutturate queste regole, entriamo in modalità sviluppo e andiamo in:\nSettings -\u0026gt; Technical -\u0026gt; Security -\u0026gt; Access Control List\nCi troveremo di fronte a una pagina come questa:\nQuindi quello che dovremo fare è aggiungere un Odoo data file, come per le viste, contenente le informazioni che voglioamo caricare in questa tabella relative ai nostri modelli.\nSolitamente le regole di accesso vengono inserite nella cartella security all\u0026rsquo;interno del modulo in cui stiamo lavorando. Quindi creaiamola e al suo interno aggiungiamo un file todo_model_acl.xml ottenendo questa struttura\ntodo_app/ models/ __init__.py todo_model.py todo_views.py views/ todo_menu.xml todo_views.xml security/ todo_model_acl.xml __init__.py __manifest__.py  All\u0026rsquo;interno del file todo_model_acl.xml andiamo poi a definire i dati che regoleranno l\u0026rsquo;acl in questione nel seguente modo\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;data noupdate=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;record model=\u0026quot;ir.model.access\u0026quot; id=\u0026quot;todo_task_user_access\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.user\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model_id\u0026quot; ref=\u0026quot;model_todo_task\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;group_id\u0026quot; ref=\u0026quot;base.group_user\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;perm_read\u0026quot; eval=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;perm_create\u0026quot; eval=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;perm_write\u0026quot; eval=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;perm_unlink\u0026quot; eval=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt;  Questa codice aggiunge una regola di acl con id todo_task_user_access che viene applicata al modello todo.task sul gruppo base.group.user dando tutti i permessi di lettura, scrittura, creazione e cancellazione. Il gruppo base.group.user è un gruppo generico di Odoo a cui fanno parte tutti gli utenti del sistema.\nIn questo caso abbiamo aggiunto al tag data il valore noupdate. Questo dice ad Odoo di creare la riga nel database al primo upgrade, ma di non aggiornarla durante un successivo upgrade se già presente. Questo perchè questo tipo di dati può essere modificato dall\u0026rsquo;amministratore direttamente da interfaccia web in produzione e non vogliamo che vengano resettate queste modifiche ad un successivo upgrade del modulo.\n Come per le viste dobbiamo poi specificare nel file __manifest__.py l\u0026rsquo;esistenza di questa regola, apriamo quindi il file manifesto e modifichiamolo come segue:\n{ 'name': 'Applicazione TODO', 'description': 'Gestisci i tuoi TODO', 'author': 'Fabrizio Arzeni', 'depends': ['base'], 'application': True, 'data': [ 'security/todo_model_acl.xml', # \u0026lt;-- Aggiungiamo questa riga 'views/todo_menu.xml', 'views/todo_views.xml', ] }  Avendo aggiunto una nuova risorsa dobbiamo ricordarci di fare l\u0026rsquo;upgrade del modulo lanciando da terminale:\n$ docker-compose run odoo upgrade todo_app  A questo punto il messaggio di WARNING dovrebbe essere scomparso e tutti i nostri utenti hanno ora accesso al modello del nostro modulo.\nRow-level access rule Immagina di desiderare che gli utenti che usano il nostro modulo possano accedere solo ai dati creati da loro stessi. Le regole di accesso non sono sufficienti per specificare questa logica, perchè anche in questo caso tutti avrebbero gli stessi permessi di accesso, cambierebbe solo su quali dati possono applicarle.\nIn questo caso si utilizzano le regole di accesso per riga, che selezionano tramite un domain i record ai quali applicare le regole di accesso generali. Nel nostro caso vorremo che gli utenti abbiano accesso solo a quei record che hanno il campo create_user uguale a quello dell\u0026rsquo;utente che sta utilizzando il sofware ma possono essere espresse anche regole ben più complesse.\nCome per le Access Control List le regole di riga vengono salvate in una specifica tabella di Odoo che può essere visualizzata andando nella sezione\nSettings -\u0026gt; Technical -\u0026gt; Security -\u0026gt; Record Rules\ne sempre come le ACL possiamo creare delle regole aggiungendole al file di security che abbiamo creato in precedenza. Quindi apriamo il file _security/todo_model_acl.xml e aggiungiamo dopo il record creato in precedenza\n\u0026lt;record model=\u0026quot;ir.model.access\u0026quot; id=\u0026quot;todo_task_user_rule\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.user.rule\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model_id\u0026quot; ref=\u0026quot;model_todo_task\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;domain_force\u0026quot;\u0026gt; [('create_uid', '=', user.id)] \u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;groups\u0026quot; eval=\u0026quot;[4, ref('base.group_user')]\u0026quot;/\u0026gt; \u0026lt;/record\u0026gt;  Se tutto è andato bene la regola sarà aggiunta.\nContinua Il nostro modulo sembra essere ad un buon punto ormai da meritare possiamo quindi andare a scoprire come si modificano le applicazioni esistenti\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/views/",
	"title": "Le Viste",
	"tags": [],
	"description": "",
	"content": " Chapter 5 VISTE Come disegnare l\u0026rsquo;interfaccia utente con il framework Odoo\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/",
	"title": "Index",
	"tags": [],
	"description": "",
	"content": " Odoo WorkShop Riferimenti L\u0026rsquo;inizio del corso:\nOdoo Workshoop\nIl modulo che svilupperemo:\nTodo List App\nIl nostro repository di riferimento:\nOdoo 11 - Immagine Docker\nLa documentazione ufficiale di odoo:\nDocumentazione Odoo\nPer problemi o domande sul workshop apri una issue su github:\nFai una domanda\nLa nostra azienda:\nMetadonors\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/views/altre_views/",
	"title": "Altre Viste",
	"tags": [],
	"description": "",
	"content": " Sono disponibili anche altre viste che pero\u0026rsquo; esulano dallo scopo di questo corso, una breve panoramica\nViste Report Viste Calendario Viste Kanban Viste Gantt Viste Diagram "
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/application_logic/",
	"title": "Logica applicativa",
	"tags": [],
	"description": "",
	"content": " Chapter 6 Logica applicativa Con le API di Odoo è possibile descrivere logiche applicative complesse e wizard per dare all\u0026rsquo;utente un\u0026rsquo;elaborata esperienza utente.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/api/",
	"title": "Api esterne",
	"tags": [],
	"description": "",
	"content": " Chapter 7 Accesso con API Esterne Nessun software è un\u0026rsquo;isola. Ogni applicazione moderna deve avere un API che gli permetta di integrarsi facilemente con l\u0026rsquo;esterno. Di seguito vediamo che tipo di approccio utilizza Odoo.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/resources/",
	"title": "Altre Risorse",
	"tags": [],
	"description": "",
	"content": " Libri Odoo Development Essentials 11 Daniel Reis\nUna lettura essenziale e must-have per lavorare con Odoo. E\u0026rsquo; il libro da cui trae ispirazione questo breve corso e che contiene moltissime altre informazioni che per ragioni di tempo e spazio non potevano essere citate qui.\nOdoo Development Essentials 11\nOdoo Development Cookbook 11 Alexandre Fayolle, Holger Brunn\nAltro manuale utilissimo. Al posto di una strutura lineare a corso, il libro è suddiviso in tanti problemi con la relativa soluzione. Utile se si ha già dimestichezza con il framework.\nOdoo Development Cookbook 11\nWorking with Odoo 11 Greg Moss\nUna lettura molto meno tecnica, si parla molto poco di come sviluppare con Odoo, in compenso contiene molte informazioni sugli aspetti funzionali dei moduli già esistenti, sul loro uso e sulla loro configurazione\nWorking with Odoo\nDocumentazione Online La documentazione ufficiale di Odoo Documentazione ufficiale di Odoo\nLa pagina ufficiale di OCA (Odoo Community Association) Homepage OCA\nProgetto Community di Documentazione Odoo Odoo Development\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]